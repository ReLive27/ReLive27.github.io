<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>ReLive27的博客</title>
  
  
  <link href="https://relive27.github.io/atom.xml" rel="self"/>
  
  <link href="https://relive27.github.io/"/>
  <updated>2022-06-16T01:19:54.534Z</updated>
  <id>https://relive27.github.io/</id>
  
  <author>
    <name>ReLive27</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Java Weekly 第1期</title>
    <link href="https://relive27.github.io/2022/06/12/java-weekly-1/"/>
    <id>https://relive27.github.io/2022/06/12/java-weekly-1/</id>
    <published>2022-06-12T09:24:47.000Z</published>
    <updated>2022-06-16T01:19:54.534Z</updated>
    
    <content type="html"><![CDATA[<!-- java weekly 1--><html><head></head><body><span id="more"></span><h2 id="精选文章"><a href="#精选文章" class="headerlink" title="精选文章"></a>精选文章</h2><ul><li><p><a href="https://www.baeldung.com/postman-send-csrf-token">&gt;&gt;从 Postman REST 客户端发送 CSRF 令牌 [baeldung.com]</a></p></li><li><p><a href="https://medium.com/@onyalioscar/implementing-2-way-ssl-and-acl-authentication-for-kafka-with-spring-boot-client-configuration-90221cda046b">&gt;&gt;使用 Spring Boot 客户端配置为 Kafka 实现 2 路 SSL 和 ACL 身份验证 [medium.com]</a></p></li><li><p><a href="https://medium.com/javarevisited/the-java-programmer-roadmap-f9db163ef2c2">2022 Java 程序员路线图 [medium.com]</a></p></li></ul><h2 id="技术-amp-思考"><a href="#技术-amp-思考" class="headerlink" title="技术&amp;思考"></a>技术&amp;思考</h2><ul><li><a href="https://medium.com/@AxelDietrichDev/10-things-i-would-have-liked-to-know-when-i-started-working-as-a-software-engineer-8c4401fcdedf">&gt;&gt;当我开始担任软件工程师时，我想知道的 10 件事 [medium.com]</a></li></ul></body></html>]]></content>
    
    
    <summary type="html">&lt;!-- java weekly 1--&gt;&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt;</summary>
    
    
    
    <category term="weekly" scheme="https://relive27.github.io/categories/weekly/"/>
    
    
  </entry>
  
  <entry>
    <title>Mybatis-plus遇到MySQL关键字如何解决</title>
    <link href="https://relive27.github.io/2022/05/18/mybatis-mysql-keyword/"/>
    <id>https://relive27.github.io/2022/05/18/mybatis-mysql-keyword/</id>
    <published>2022-05-18T09:33:52.000Z</published>
    <updated>2022-05-27T05:00:38.355Z</updated>
    
    <content type="html"><![CDATA[<!-- mybatis--><html><head></head><body><span id="more"></span><h2 id="Mybatis-plus遇到MySQL关键字如何解决"><a href="#Mybatis-plus遇到MySQL关键字如何解决" class="headerlink" title="Mybatis-plus遇到MySQL关键字如何解决"></a>Mybatis-plus遇到MySQL关键字如何解决</h2><p>在我们开发中经常会遇到在实体类中某个字段是MySQL的关键字，例如：</p><figure class="highlight java hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@TableName</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="title class_">User</span> {</span><br><span class="line">  <span class="hljs-keyword">private</span> Long id;</span><br><span class="line">  <span class="hljs-keyword">private</span> String username;</span><br><span class="line">  <span class="hljs-keyword">private</span> String describe;</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>在我们使用Mybatis查询是会遇到报错，提示信息：</p><figure class="highlight plaintext hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1064 - You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near 'describe from user' at line 1, Time: 0.009000s</span><br></pre></td></tr></tbody></table></figure><p>这是因为Mybatis在执行sql时并没有将查询字段并没有通过**``**符号，所以MySQL会把describe当作关键字。</p><p>首先遇到这种情况，一我们可以更改字段名避免使用MySQL的关键字；二如果字段名不方便修改，那么我们可以使用<code>@TableField</code>显示的将字段使用**``**。修改后实体类如下：</p><figure class="highlight java hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@TableName</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="title class_">User</span> {</span><br><span class="line">  <span class="hljs-keyword">private</span> Long id;</span><br><span class="line">  <span class="hljs-keyword">private</span> String username;</span><br><span class="line">  <span class="hljs-meta">@TableName("`describe`")</span></span><br><span class="line">  <span class="hljs-keyword">private</span> String describe;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></body></html>]]></content>
    
    
    <summary type="html">&lt;!-- mybatis--&gt;&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt;</summary>
    
    
    
    <category term="Mybatis" scheme="https://relive27.github.io/categories/Mybatis/"/>
    
    
    <category term="Mybatis" scheme="https://relive27.github.io/tags/Mybatis/"/>
    
  </entry>
  
  <entry>
    <title>设计模式-工厂方法模式</title>
    <link href="https://relive27.github.io/2022/05/15/factory-pattern/"/>
    <id>https://relive27.github.io/2022/05/15/factory-pattern/</id>
    <published>2022-05-15T12:24:52.000Z</published>
    <updated>2022-06-14T04:33:25.412Z</updated>
    
    <content type="html"><![CDATA[<!--factory--><html><head></head><body><span id="more"></span><h2 id="工厂方法模式"><a href="#工厂方法模式" class="headerlink" title="工厂方法模式"></a>工厂方法模式</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>工厂方法模式使用的频率非常高，在日常开发中经常会使用，其定义为：</p><p>定义一个用于创建对象的接口，让子类决定实例化哪一个类。工厂方法使一个类的实例化延迟到其子类。</p><p>通用类图如下：</p><p><img src="/2022/05/15/factory-pattern/factory-pattern.png"></p><p>工厂方法模式中，抽象产品类定义产品的共性；Factory为抽象创建类，也就是抽象工厂。代码如下：</p><p>抽象产品类代码：</p><figure class="highlight java hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="title class_">Product</span> {</span><br><span class="line"></span><br><span class="line">    <span class="hljs-comment">//产品类的公共方法</span></span><br><span class="line">    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="title function_">method1</span><span class="hljs-params">()</span>{</span><br><span class="line">        <span class="hljs-comment">//doSomething</span></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="title function_">method2</span><span class="hljs-params">()</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>具体产品类可以有多个，都继承与抽象产品类，代码如下：</p><figure class="highlight java hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="title class_">ConcreteProduct1</span>  <span class="hljs-keyword">extends</span> <span class="title class_">Product</span>{</span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="title function_">method2</span><span class="hljs-params">()</span> {</span><br><span class="line">        System.out.println(<span class="hljs-string">"具体产品类1"</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="title class_">ConcreteProduct2</span>  <span class="hljs-keyword">extends</span> <span class="title class_">Product</span>{</span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="title function_">method2</span><span class="hljs-params">()</span> {</span><br><span class="line">        System.out.println(<span class="hljs-string">"具体产品类2"</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>抽象工厂类负责定义产品对象产生，代码如下：</p><figure class="highlight java hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="title class_">ProductFactory</span> {</span><br><span class="line"><span class="hljs-comment">//创建一个产品类对象，参数可以自行设置</span></span><br><span class="line">    &lt;T <span class="hljs-keyword">extends</span> <span class="title class_">Product</span>&gt; T <span class="title function_">createProduct</span><span class="hljs-params">(Class&lt;T&gt; clazz)</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>具体如何产生一个产品的对象，由具体的工厂类实现，代码如下：</p><figure class="highlight java hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="title class_">ConcreteProductFactory</span> <span class="hljs-keyword">implements</span> <span class="title class_">ProductFactory</span> {</span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-keyword">public</span> &lt;T <span class="hljs-keyword">extends</span> <span class="title class_">Product</span>&gt; T <span class="title function_">createProduct</span><span class="hljs-params">(Class&lt;T&gt; clazz)</span> {</span><br><span class="line">        <span class="hljs-type">Product</span> <span class="hljs-variable">product</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;</span><br><span class="line">        <span class="hljs-keyword">try</span> {</span><br><span class="line">            product = (Product) Class.forName(clazz.getName()).newInstance();</span><br><span class="line">        } <span class="hljs-keyword">catch</span> (Exception e) {</span><br><span class="line">            <span class="hljs-comment">//异常处理</span></span><br><span class="line">        }</span><br><span class="line">        <span class="hljs-keyword">return</span> (T) product;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="工厂方法模式优点"><a href="#工厂方法模式优点" class="headerlink" title="工厂方法模式优点"></a>工厂方法模式优点</h3><ul><li>良好的封装性，代码结构清晰。对于客户端隐藏创建对象的复杂过程，降低模块间的耦合。</li><li>扩展性高。在增加产品类的情况下，只要修改具体的工厂类或扩展一个工厂类。</li><li>屏蔽产品类。产品类的实现如何变化，客户端都不需要关心，他只需要关心产品的接口，因为产品类的实例化由工厂类负责。</li><li>工厂方法模式是典型的解耦框架。高层模块只需要知道产品的抽象类，其他实现类都不关心，符合迪米特法则。只依赖产品类的抽象，符合依赖倒置原则。使用产品子类替换产品父类，也符合里氏替换原则。</li></ul><h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><p>工厂方法模式是new一个对象的替代品，在需要灵活的，可扩展的框架时，可以考虑采用工厂方法模式。例如使用JDBC数据库连接，数据库从MySQL切换到Oracle，需要改动的地方就是切换下驱动名称（前提SQL是标准语句）。</p><h3 id="工厂方法模式的扩展"><a href="#工厂方法模式的扩展" class="headerlink" title="工厂方法模式的扩展"></a>工厂方法模式的扩展</h3><h4 id="简单工厂模式"><a href="#简单工厂模式" class="headerlink" title="简单工厂模式"></a>简单工厂模式</h4><p>在工厂方法模式中，我们考虑<strong>一个模块只需要一个工厂类</strong>，根据这一需求，稍微改动下，将抽象工厂类去掉，类图如下：</p><p><img src="/2022/05/15/factory-pattern/factory-pattern(1).png"></p><p>我们去掉Factory抽象类，并把创建createProduct方法设置为静态类型，变更代码如下：</p><figure class="highlight java hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="title class_">ConcreteProductFactory</span> {</span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-keyword">public</span> &lt;T <span class="hljs-keyword">extends</span> <span class="title class_">Product</span>&gt; T <span class="title function_">createProduct</span><span class="hljs-params">(Class&lt;T&gt; clazz)</span> {</span><br><span class="line">        <span class="hljs-type">Product</span> <span class="hljs-variable">product</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;</span><br><span class="line">        <span class="hljs-keyword">try</span> {</span><br><span class="line">            product = (Product) Class.forName(clazz.getName()).newInstance();</span><br><span class="line">        } <span class="hljs-keyword">catch</span> (Exception e) {</span><br><span class="line">            <span class="hljs-comment">//异常处理</span></span><br><span class="line">        }</span><br><span class="line">        <span class="hljs-keyword">return</span> (T) product;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>简单工厂模式是工厂模式的弱化，在实际开发中，采用此模式还是比较多的，但是其缺点是工厂类的扩展比较困难，不符合开闭原则。</p><h4 id="多工厂类"><a href="#多工厂类" class="headerlink" title="多工厂类"></a>多工厂类</h4><p>当我们做一个复杂项目时，如果遇到一个对象初始化很耗费精力的情况，那么将所有产品类放到一个工厂方法中会使结构不清晰，例如产品类有5个具体实现，那么此时工厂方法可能会变得巨大无比。</p><p>考虑需要结构清晰，我们就为每个产品类创造一个工厂类，由客户端决定与哪个工厂方法关联。</p><p>多工厂模式的抽象工厂类代码如下：</p><figure class="highlight java hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="title class_">MultiProductFactory</span> {</span><br><span class="line"></span><br><span class="line">    Product <span class="title function_">createProduct</span><span class="hljs-params">()</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>此时抽象方法不需要传递参数，因为每个具体工厂职责已经很明确了，只需要负责创建自己负责的产品类对象。</p><p>产品类1工厂类实现：</p><figure class="highlight java hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="title class_">Concrete1MultiProductFactory</span> <span class="hljs-keyword">implements</span> <span class="title class_">MultiProductFactory</span>{</span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-keyword">public</span> Product <span class="title function_">createProduct</span><span class="hljs-params">()</span> {</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="title class_">ConcreteProduct1</span>();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>产品类2工程类实现：</p><figure class="highlight java hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="title class_">Concrete2MultiProductFactory</span> <span class="hljs-keyword">implements</span> <span class="title class_">MultiProductFactory</span> {</span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-keyword">public</span> Product <span class="title function_">createProduct</span><span class="hljs-params">()</span> {</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="title class_">ConcreteProduct2</span>();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>此种模式就是创建类职责清晰，但是给扩展性和维护性带来了一定的影响。如果扩展一个产品类，就需要建立相应的工厂类，这样增加了扩展的难度。因为工厂类和产品类数量相同，维护时需要考虑两个对象之间的关系。当然在采用多工厂时，可以增加一个协调类，避免客户端与各个子工厂交流，协调类的作用封装子工厂类，对外提供统一的访问接口。</p><h4 id="延迟初始化"><a href="#延迟初始化" class="headerlink" title="延迟初始化"></a>延迟初始化</h4><p>一个对象消费完毕后，并不立刻释放，工厂类保持其初始状态，等待再次被调用。延迟初始化是工厂方法模式的一个扩展应用。</p><p>工厂类负责对象的创建工作，并通过HashMap产生一个缓存，对需要再次被调用的对象保留，参考代码如下：</p><figure class="highlight java hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="title class_">LazyProductFactory</span> {</span><br><span class="line">    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Map&lt;String, Product&gt; map = <span class="hljs-keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">synchronized</span> Product <span class="title function_">createProduct</span><span class="hljs-params">(String type)</span> {</span><br><span class="line">        Product product;</span><br><span class="line">        <span class="hljs-keyword">if</span> (map.containsKey(type)) {</span><br><span class="line">            product = map.get(type);</span><br><span class="line">        } <span class="hljs-keyword">else</span> {</span><br><span class="line">            <span class="hljs-keyword">if</span> (<span class="hljs-string">"product1"</span>.equals(type)) {</span><br><span class="line">                product = <span class="hljs-keyword">new</span> <span class="title class_">ConcreteProduct1</span>();</span><br><span class="line">            } <span class="hljs-keyword">else</span> {</span><br><span class="line">                product = <span class="hljs-keyword">new</span> <span class="title class_">ConcreteProduct2</span>();</span><br><span class="line">            }</span><br><span class="line">            map.put(type, product);</span><br><span class="line">        }</span><br><span class="line">        <span class="hljs-keyword">return</span> product;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>实现比较简单，通过定义一个Map容器，缓存所有产生的对象，再次调用时如果Map中已经包含则直接返回，否则根据需要产生一个对象并存Map中。</p><h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><p>与往常一样，本文中使用的源代码可<a href="https://github.com/ReLive27/Java/tree/master/designPatterns/src/main/java/com/relive/factory">在 GitHub 上</a>获得。</p></body></html>]]></content>
    
    
    <summary type="html">&lt;!--factory--&gt;&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt;</summary>
    
    
    
    <category term="设计模式" scheme="https://relive27.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
  </entry>
  
  <entry>
    <title>使用Java连接SSH</title>
    <link href="https://relive27.github.io/2022/05/15/java-ssh/"/>
    <id>https://relive27.github.io/2022/05/15/java-ssh/</id>
    <published>2022-05-15T09:24:47.000Z</published>
    <updated>2022-05-16T11:57:51.007Z</updated>
    
    <content type="html"><![CDATA[<!--ssh--><html><head></head><body><span id="more"></span><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p><a href="https://baike.baidu.com/item/ssh/10407?fr=aladdin">SSH</a> 为建立在应用层基础上的安全协议。SSH 是较可靠，专为远程登录会话和其他网络服务提供安全性的协议。</p><h2 id="Jsch"><a href="#Jsch" class="headerlink" title="Jsch"></a>Jsch</h2><p>JSch 是 <a href="http://ietf.org/html.charters/secsh-charter.html">SSH2</a>的纯 Java 实现。JSch 允许你连接到一个 sshd 服务器并使用端口转发、X11 转发、文件传输等，你可以将它的功能集成到你自己的 Java 程序中。</p><p>首先，让我们将<a href="https://mvnrepository.com/artifact/com.jcraft/jsch">JSch Maven 依赖</a>添加到我们的<em>pom.xml</em>文件中：</p><figure class="highlight xml hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.jcraft<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>jsch<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>0.1.55<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><h3 id="执行"><a href="#执行" class="headerlink" title="执行"></a>执行</h3><p>要使用Jsch连接ssh，需要提供<strong>用户名</strong>，<strong>密码</strong>，<strong>主机</strong>，<strong>端口</strong>，以下是简单代码实例：</p><figure class="highlight java hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="title function_">execCommand</span><span class="hljs-params">(String username, String password, String host, Integer port, String command)</span> <span class="hljs-keyword">throws</span> JSchException, InterruptedException {</span><br><span class="line">       <span class="hljs-type">Session</span> <span class="hljs-variable">session</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;</span><br><span class="line">       <span class="hljs-type">ChannelExec</span> <span class="hljs-variable">channel</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;</span><br><span class="line"></span><br><span class="line">       <span class="hljs-keyword">try</span> {</span><br><span class="line">           session = <span class="hljs-keyword">new</span> <span class="title class_">JSch</span>().getSession(username, host, port);</span><br><span class="line">           session.setPassword(password);</span><br><span class="line">           session.setConfig(<span class="hljs-string">"StrictHostKeyChecking"</span>, <span class="hljs-string">"no"</span>);</span><br><span class="line">           session.connect();</span><br><span class="line"></span><br><span class="line">           channel = (ChannelExec) session.openChannel(<span class="hljs-string">"exec"</span>);</span><br><span class="line">           channel.setCommand(command);</span><br><span class="line">           <span class="hljs-type">ByteArrayOutputStream</span> <span class="hljs-variable">responseStream</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="title class_">ByteArrayOutputStream</span>();</span><br><span class="line">           channel.setOutputStream(responseStream);</span><br><span class="line">           <span class="hljs-type">ByteArrayOutputStream</span> <span class="hljs-variable">errorResponseStream</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="title class_">ByteArrayOutputStream</span>();</span><br><span class="line">           channel.setErrStream(errorResponseStream);</span><br><span class="line">           channel.connect();</span><br><span class="line"></span><br><span class="line">           <span class="hljs-keyword">while</span> (channel.isConnected()) {</span><br><span class="line">               Thread.sleep(<span class="hljs-number">100</span>);</span><br><span class="line">           }</span><br><span class="line"></span><br><span class="line">           <span class="hljs-type">String</span> <span class="hljs-variable">responseString</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="title class_">String</span>(responseStream.toByteArray(), StandardCharsets.UTF_8);</span><br><span class="line">           <span class="hljs-keyword">if</span> (!responseString.isEmpty()) {</span><br><span class="line">               log.info(responseString);</span><br><span class="line">           }</span><br><span class="line">           <span class="hljs-type">String</span> <span class="hljs-variable">errorResponseString</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="title class_">String</span>(errorResponseStream.toByteArray(), StandardCharsets.UTF_8);</span><br><span class="line">           <span class="hljs-keyword">if</span> (!errorResponseString.isEmpty()) {</span><br><span class="line">               log.warn(errorResponseString);</span><br><span class="line">           }</span><br><span class="line">       } <span class="hljs-keyword">finally</span> {</span><br><span class="line">           <span class="hljs-keyword">if</span> (session != <span class="hljs-literal">null</span>) {</span><br><span class="line">               session.disconnect();</span><br><span class="line">           }</span><br><span class="line">           <span class="hljs-keyword">if</span> (channel != <span class="hljs-literal">null</span>) {</span><br><span class="line">               channel.disconnect();</span><br><span class="line">           }</span><br><span class="line">       }</span><br><span class="line">   }</span><br></pre></td></tr></tbody></table></figure><p>上述代码中我们首先建立SSH会话，通过会话建立执行通道，执行我们提供的shell命令，并将响应信息和错误响应信息输出到控制台。</p><p><strong>如何使用 JSch 提供的不同配置参数</strong>：</p><ul><li><em>StrictHostKeyChecking</em> - 它指示应用程序是否将检查是否可以在已知主机中找到主机公钥。此外，可用的参数值是<em>ask</em>、<em>yes</em>和<em>no</em>，其中<em>ask</em>是默认值。如果我们将此属性设置为<em>yes</em>，JSch 将永远不会自动将主机密钥添加到<em>known_hosts</em>文件，并且它将拒绝连接到主机密钥已更改的主机。这会强制用户手动添加所有新主机。如果我们将其设置为 <em>no</em>，JSch 会自动将新的主机密钥添加到已知主机列表中</li><li><em>compression.s2c</em> – 指定是否对从服务器到客户端应用程序的数据流使用压缩。可用值为<em>zlib</em>和<em>none</em>，其中第二个是默认值</li><li><em>compression.c2s</em> – 指定是否对客户端-服务器方向的数据流使用压缩。可用值为<em>zlib</em>和<em>none</em>，其中第二个是默认值</li></ul><h2 id="Apache-MINA-SSHD"><a href="#Apache-MINA-SSHD" class="headerlink" title="Apache MINA SSHD"></a>Apache MINA SSHD</h2><p><a href="https://mina.apache.org/sshd-project/">Apache SSHD</a> 是一个 100% 纯 Java 库，支持客户端和服务器端的 SSH 协议。该库基于<a href="http://mina.apache.org/">Apache MINA</a>，这是一个可扩展的高性能异步 IO 库。</p><p>首先，让我们将<a href="https://mvnrepository.com/artifact/org.apache.sshd/sshd-core">sshd Maven 依赖</a>添加到我们的<em>pom.xml</em>文件中：</p><figure class="highlight xml hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.sshd<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>sshd-core<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.8.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><h3 id="执行-1"><a href="#执行-1" class="headerlink" title="执行"></a>执行</h3><p>同样，建立ssh连接需要提供<strong>用户名</strong>，<strong>密码</strong>，<strong>主机地址</strong>，<strong>端口</strong>，除此之外，sshd可以设置<strong>连接超时时间</strong>，以下提供简单的代码示例：</p><figure class="highlight java hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="title function_">execCommand</span><span class="hljs-params">(String username, String password, String host, Integer port, Integer defaultTimeoutSeconds, String command)</span> <span class="hljs-keyword">throws</span> IOException {</span><br><span class="line">       <span class="hljs-type">SshClient</span> <span class="hljs-variable">client</span> <span class="hljs-operator">=</span> SshClient.setUpDefaultClient();</span><br><span class="line">       client.start();</span><br><span class="line">       <span class="hljs-keyword">try</span> (<span class="hljs-type">ClientSession</span> <span class="hljs-variable">session</span> <span class="hljs-operator">=</span> client.connect(username, host, port)</span><br><span class="line">               .verify(defaultTimeoutSeconds, TimeUnit.SECONDS)</span><br><span class="line">               .getSession()) {</span><br><span class="line">           session.addPasswordIdentity(password);</span><br><span class="line">           session.auth().verify(defaultTimeoutSeconds, TimeUnit.SECONDS);</span><br><span class="line">           <span class="hljs-keyword">try</span> (<span class="hljs-type">ByteArrayOutputStream</span> <span class="hljs-variable">responseStream</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="title class_">ByteArrayOutputStream</span>();</span><br><span class="line">                <span class="hljs-type">ByteArrayOutputStream</span> <span class="hljs-variable">errorResponseStream</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="title class_">ByteArrayOutputStream</span>();</span><br><span class="line">                <span class="hljs-type">ClientChannel</span> <span class="hljs-variable">channel</span> <span class="hljs-operator">=</span> session.createChannel(Channel.CHANNEL_SHELL)) {</span><br><span class="line">               channel.setOut(responseStream);</span><br><span class="line">               channel.setErr(errorResponseStream);</span><br><span class="line">               <span class="hljs-keyword">try</span> {</span><br><span class="line">                   channel.open().verify(defaultTimeoutSeconds, TimeUnit.SECONDS);</span><br><span class="line">                   <span class="hljs-keyword">try</span> (<span class="hljs-type">OutputStream</span> <span class="hljs-variable">pipedIn</span> <span class="hljs-operator">=</span> channel.getInvertedIn()) {</span><br><span class="line">                       pipedIn.write(command.getBytes());</span><br><span class="line">                       pipedIn.flush();</span><br><span class="line">                   }</span><br><span class="line">                   channel.waitFor(EnumSet.of(ClientChannelEvent.CLOSED), TimeUnit.SECONDS.toMillis(defaultTimeoutSeconds));</span><br><span class="line">                   <span class="hljs-type">String</span> <span class="hljs-variable">errorString</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="title class_">String</span>(errorResponseStream.toByteArray());</span><br><span class="line">                   <span class="hljs-keyword">if</span> (!errorString.isEmpty()) {</span><br><span class="line">                       log.warn(errorString);</span><br><span class="line">                   }</span><br><span class="line">                   <span class="hljs-type">String</span> <span class="hljs-variable">responseString</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="title class_">String</span>(responseStream.toByteArray());</span><br><span class="line">                   <span class="hljs-keyword">if</span> (!responseString.isEmpty()) {</span><br><span class="line">                       log.info(responseString);</span><br><span class="line">                   }</span><br><span class="line">               } <span class="hljs-keyword">finally</span> {</span><br><span class="line">                   channel.close(<span class="hljs-literal">false</span>);</span><br><span class="line">               }</span><br><span class="line">           }</span><br><span class="line">       } <span class="hljs-keyword">finally</span> {</span><br><span class="line">           client.stop();</span><br><span class="line">       }</span><br><span class="line">   }</span><br></pre></td></tr></tbody></table></figure><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>与往常一样，本文中使用的源代码可<a href="https://github.com/ReLive27/Java/tree/master/security/src/main/java/com/relive/ssh">在 GitHub 上</a>获得。</p></body></html>]]></content>
    
    
    <summary type="html">&lt;!--ssh--&gt;&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt;</summary>
    
    
    
    <category term="java" scheme="https://relive27.github.io/categories/java/"/>
    
    
    <category term="ssh" scheme="https://relive27.github.io/tags/ssh/"/>
    
  </entry>
  
  <entry>
    <title>设计模式-单例模式</title>
    <link href="https://relive27.github.io/2022/05/11/singleton-pattern/"/>
    <id>https://relive27.github.io/2022/05/11/singleton-pattern/</id>
    <published>2022-05-11T12:26:19.000Z</published>
    <updated>2022-06-14T04:33:40.925Z</updated>
    
    <content type="html"><![CDATA[<!--singleton--><html><head></head><body><span id="more"></span><h2 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h2><p>单例模式是设计模式中比较简单的模式，也是很常用的模式，其定义如下：</p><p><strong>确保某一个类只有一个实例，而且自行实例化并向整个系统提供这个实例</strong>。</p><p>通用类图如下：</p><p><img src="/2022/05/11/singleton-pattern/C46A72CE-5EA4-4A94-89F0-BE215780E639.jpeg"></p><p>通过私有化构造函数确保在一个应用中只有一个实例，并提供静态方法发布对象。</p><p>单例模式通用代码（也被称为饿汉式）：</p><figure class="highlight java hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="title class_">Singleton</span> {</span><br><span class="line">  <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Singleton singleton= <span class="hljs-keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">  <span class="hljs-comment">//限制多个对象</span></span><br><span class="line">  <span class="hljs-keyword">private</span> <span class="title function_">Singleton</span> <span class="hljs-params">()</span>{}</span><br><span class="line">  </span><br><span class="line">  <span class="hljs-comment">//通过该方法获得实例对象</span></span><br><span class="line">  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="title function_">getSingleton</span><span class="hljs-params">()</span> {</span><br><span class="line">    <span class="hljs-keyword">return</span> singleton;</span><br><span class="line">  }</span><br><span class="line">  </span><br><span class="line">  <span class="hljs-comment">//在类中其他方法，尽量是static</span></span><br><span class="line">  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="title function_">doSomething</span><span class="hljs-params">()</span>{</span><br><span class="line">    ...</span><br><span class="line">  }</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><h3 id="单例模式的优点"><a href="#单例模式的优点" class="headerlink" title="单例模式的优点"></a>单例模式的优点</h3><ul><li>减少内存开支，特别是一个对象频繁的创建和销毁时。</li><li>减少系统性能开销，当一个对象的产生需要比较多的资源时，可以通过启动时产生一个单例对象。</li><li>单例模式可以避免对资产的多重占用。</li><li>单例模式可以在系统设置全局的访问点，优化和共享资源访问。</li></ul><h3 id="单例模式的缺点"><a href="#单例模式的缺点" class="headerlink" title="单例模式的缺点"></a>单例模式的缺点</h3><ul><li>单例模式对测试不利，在并行开发中，如果单例模式没有完成，是不能进行测试的，因为没有接口也不能mock的方式虚拟一个对象</li><li>单例模式与单一职责原则有冲突，一个类应该只实现一个逻辑，单例模式把“要单例”和业务逻辑合在一个类中</li></ul><h3 id="单例模式使用场景"><a href="#单例模式使用场景" class="headerlink" title="单例模式使用场景"></a>单例模式使用场景</h3><p>系统中要求一个类只有一个对象，当存在多个对象时会产生错误影响，可以使用单例模式。</p><ul><li>要求生成唯一序列号的环境</li><li>在项目中需要一个共享访问点和共享数据</li><li>创建一个对象需要消耗很多资源。</li><li>需要定义大量的静态常量和静态方法（如工具类）</li></ul><h3 id="单例模式的注意事项"><a href="#单例模式的注意事项" class="headerlink" title="单例模式的注意事项"></a>单例模式的注意事项</h3><p>在高并发情况下，单例模式存在线程同步问题，如下面的一种单例模式实现方式（也称为懒汉式）：</p><figure class="highlight java hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="title class_">Singleton</span> {</span><br><span class="line">  <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">Singleton</span> <span class="hljs-variable">singleton</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="hljs-comment">//限制产生多个对象</span></span><br><span class="line">  <span class="hljs-keyword">private</span> <span class="title function_">Singleton</span><span class="hljs-params">()</span>{}</span><br><span class="line">  </span><br><span class="line">  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="title function_">getSingleton</span><span class="hljs-params">()</span> {</span><br><span class="line">    <span class="hljs-keyword">if</span>(singleton == <span class="hljs-literal">null</span>){</span><br><span class="line">      singleton = <span class="hljs-keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">    }</span><br><span class="line">    <span class="hljs-keyword">return</span> singleton;</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>在并发量增加时可能会出现多个实例，如一个线程A执行到singleton = new Singleton()，但是还没有获得对象，第二个线程B也在执行，执行到singleton == null判断，判断条件为真，于是运行下去也创建了一个对象。</p><p>解决线程不安全问题方法有很多，一使用饿汉式的实现方式，静态变量在类加载时初始化，类加载过程是线程安全的，所以饿汉式没有线程安全问题；二是使用Java的锁机制，以下代码示例单例模式（懒汉式）的双重检锁机制：</p><figure class="highlight java hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="title class_">Singleton</span> {</span><br><span class="line">  <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">volatile</span> <span class="hljs-type">Singleton</span> <span class="hljs-variable">singleton</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="hljs-comment">//限制产生多个对象</span></span><br><span class="line">  <span class="hljs-keyword">private</span> <span class="title function_">Singleton</span><span class="hljs-params">()</span>{}</span><br><span class="line">  </span><br><span class="line">    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="title function_">getSingleton</span><span class="hljs-params">()</span> {</span><br><span class="line">        <span class="hljs-keyword">if</span> (singleton == <span class="hljs-literal">null</span>) {</span><br><span class="line">            <span class="hljs-keyword">synchronized</span> (Singleton.class) {</span><br><span class="line">                <span class="hljs-keyword">if</span> (singleton == <span class="hljs-literal">null</span>) {</span><br><span class="line">                    singleton = <span class="hljs-keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">      <span class="hljs-keyword">return</span> singleton;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>总之单例模式比较简单而且应用非常广泛，在Spring框架中每个Bean默认就是单例的。</p><h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><p>与往常一样，本文中使用的源代码可<a href="https://github.com/ReLive27/Java/tree/master/designPatterns/src/main/java/com/relive/singleton">在 GitHub 上</a>获得。</p></body></html>]]></content>
    
    
    <summary type="html">&lt;!--singleton--&gt;&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt;</summary>
    
    
    
    <category term="设计模式" scheme="https://relive27.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
  </entry>
  
  <entry>
    <title>SpringBoot启动完成前后执行某个方法</title>
    <link href="https://relive27.github.io/2022/05/10/spring-start-event/"/>
    <id>https://relive27.github.io/2022/05/10/spring-start-event/</id>
    <published>2022-05-10T13:10:10.000Z</published>
    <updated>2022-05-10T12:44:04.648Z</updated>
    
    <content type="html"><![CDATA[<!-- springboot --><html><head></head><body><span id="more"></span><p>在项目启动完成之前</p><p>实现ApplicationListener<contextrefreshedevent>，ContextRefreshedEvent为启动事件。</contextrefreshedevent></p><figure class="highlight java hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Component</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="title class_">ApplicationListenerDemo</span> <span class="hljs-keyword">implements</span> <span class="title class_">ApplicationListener</span>&lt;ContextRefreshedEvent&gt; {</span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="title function_">onApplicationEvent</span><span class="hljs-params">(ContextRefreshedEvent contextRefreshedEvent)</span> {</span><br><span class="line">        System.out.println(<span class="hljs-string">"applicationListener before server success"</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="在项目启动完成之后"><a href="#在项目启动完成之后" class="headerlink" title="在项目启动完成之后"></a>在项目启动完成之后</h4><h5 id="方式一-：实现ApplicationRunner接口"><a href="#方式一-：实现ApplicationRunner接口" class="headerlink" title="方式一 ：实现ApplicationRunner接口"></a>方式一 ：实现ApplicationRunner接口</h5><figure class="highlight java hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Component</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="title class_">ApplicationRunnerDemo</span> <span class="hljs-keyword">implements</span> <span class="title class_">ApplicationRunner</span> {</span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="title function_">run</span><span class="hljs-params">(ApplicationArguments args)</span> <span class="hljs-keyword">throws</span> Exception {</span><br><span class="line">        System.out.println(<span class="hljs-string">"run after server success"</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h5 id="方式二：实现CommandLineRunner接口"><a href="#方式二：实现CommandLineRunner接口" class="headerlink" title="方式二：实现CommandLineRunner接口"></a>方式二：实现CommandLineRunner接口</h5><figure class="highlight java hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="title class_">CommandLineRunnerDemo</span> <span class="hljs-keyword">implements</span> <span class="title class_">CommandLineRunner</span> {</span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="title function_">run</span><span class="hljs-params">(String... args)</span> <span class="hljs-keyword">throws</span> Exception {</span><br><span class="line">        System.out.println(<span class="hljs-string">"commandLineRunner after server success"</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><p>启动类的run方法调用了callRunners方法</p><figure class="highlight java hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> ConfigurableApplicationContext <span class="title function_">run</span><span class="hljs-params">(String... args)</span> {</span><br><span class="line">        <span class="hljs-type">StopWatch</span> <span class="hljs-variable">stopWatch</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="title class_">StopWatch</span>();</span><br><span class="line">        stopWatch.start();</span><br><span class="line">        <span class="hljs-type">ConfigurableApplicationContext</span> <span class="hljs-variable">context</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;</span><br><span class="line">        Collection&lt;SpringBootExceptionReporter&gt; exceptionReporters = <span class="hljs-keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">        <span class="hljs-built_in">this</span>.configureHeadlessProperty();</span><br><span class="line">        <span class="hljs-type">SpringApplicationRunListeners</span> <span class="hljs-variable">listeners</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.getRunListeners(args);</span><br><span class="line">        listeners.starting();</span><br><span class="line"></span><br><span class="line">        Collection exceptionReporters;</span><br><span class="line">        <span class="hljs-keyword">try</span> {</span><br><span class="line">            <span class="hljs-type">ApplicationArguments</span> <span class="hljs-variable">applicationArguments</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="title class_">DefaultApplicationArguments</span>(args);</span><br><span class="line">            <span class="hljs-type">ConfigurableEnvironment</span> <span class="hljs-variable">environment</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.prepareEnvironment(listeners, applicationArguments);</span><br><span class="line">            <span class="hljs-built_in">this</span>.configureIgnoreBeanInfo(environment);</span><br><span class="line">            <span class="hljs-type">Banner</span> <span class="hljs-variable">printedBanner</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.printBanner(environment);</span><br><span class="line">            context = <span class="hljs-built_in">this</span>.createApplicationContext();</span><br><span class="line">            exceptionReporters = <span class="hljs-built_in">this</span>.getSpringFactoriesInstances(SpringBootExceptionReporter.class, <span class="hljs-keyword">new</span> <span class="title class_">Class</span>[]{ConfigurableApplicationContext.class}, context);</span><br><span class="line">            <span class="hljs-built_in">this</span>.prepareContext(context, environment, listeners, applicationArguments, printedBanner);</span><br><span class="line">            <span class="hljs-built_in">this</span>.refreshContext(context);</span><br><span class="line">            <span class="hljs-built_in">this</span>.afterRefresh(context, applicationArguments);</span><br><span class="line">            stopWatch.stop();</span><br><span class="line">            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.logStartupInfo) {</span><br><span class="line">                (<span class="hljs-keyword">new</span> <span class="title class_">StartupInfoLogger</span>(<span class="hljs-built_in">this</span>.mainApplicationClass)).logStarted(<span class="hljs-built_in">this</span>.getApplicationLog(), stopWatch);</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            listeners.started(context);</span><br><span class="line">          <span class="hljs-comment">//执行callRunners方法</span></span><br><span class="line">            <span class="hljs-built_in">this</span>.callRunners(context, applicationArguments);</span><br><span class="line">        } <span class="hljs-keyword">catch</span> (Throwable var10) {</span><br><span class="line">            <span class="hljs-built_in">this</span>.handleRunFailure(context, var10, exceptionReporters, listeners);</span><br><span class="line">            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="title class_">IllegalStateException</span>(var10);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="hljs-keyword">try</span> {</span><br><span class="line">            listeners.running(context);</span><br><span class="line">            <span class="hljs-keyword">return</span> context;</span><br><span class="line">        } <span class="hljs-keyword">catch</span> (Throwable var9) {</span><br><span class="line">            <span class="hljs-built_in">this</span>.handleRunFailure(context, var9, exceptionReporters, (SpringApplicationRunListeners)<span class="hljs-literal">null</span>);</span><br><span class="line">            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="title class_">IllegalStateException</span>(var9);</span><br><span class="line">        }</span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure><p>callRunners方法会调用容器里所有实现了ApplicationRunner、CommandLineRunner接口的方法</p><figure class="highlight java hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="title function_">callRunners</span><span class="hljs-params">(ApplicationContext context, ApplicationArguments args)</span> {</span><br><span class="line">        List&lt;Object&gt; runners = <span class="hljs-keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">        runners.addAll(context.getBeansOfType(ApplicationRunner.class).values());</span><br><span class="line">        runners.addAll(context.getBeansOfType(CommandLineRunner.class).values());</span><br><span class="line">        AnnotationAwareOrderComparator.sort(runners);</span><br><span class="line">        <span class="hljs-type">Iterator</span> <span class="hljs-variable">var4</span> <span class="hljs-operator">=</span> (<span class="hljs-keyword">new</span> <span class="title class_">LinkedHashSet</span>(runners)).iterator();</span><br><span class="line"></span><br><span class="line">        <span class="hljs-keyword">while</span>(var4.hasNext()) {</span><br><span class="line">            <span class="hljs-type">Object</span> <span class="hljs-variable">runner</span> <span class="hljs-operator">=</span> var4.next();</span><br><span class="line">            <span class="hljs-keyword">if</span> (runner <span class="hljs-keyword">instanceof</span> ApplicationRunner) {</span><br><span class="line">                <span class="hljs-built_in">this</span>.callRunner((ApplicationRunner)runner, args);</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            <span class="hljs-keyword">if</span> (runner <span class="hljs-keyword">instanceof</span> CommandLineRunner) {</span><br><span class="line">                <span class="hljs-built_in">this</span>.callRunner((CommandLineRunner)runner, args);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure></body></html>]]></content>
    
    
    <summary type="html">&lt;!-- springboot --&gt;&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt;</summary>
    
    
    
    <category term="springboot" scheme="https://relive27.github.io/categories/springboot/"/>
    
    
    <category term="springboot" scheme="https://relive27.github.io/tags/springboot/"/>
    
  </entry>
  
  <entry>
    <title>SpringBoot整合redis</title>
    <link href="https://relive27.github.io/2022/05/10/springboot-integrate-redis/"/>
    <id>https://relive27.github.io/2022/05/10/springboot-integrate-redis/</id>
    <published>2022-05-10T12:23:20.000Z</published>
    <updated>2022-05-10T12:36:11.383Z</updated>
    
    <content type="html"><![CDATA[<!--redis--><html><head></head><body><span id="more"></span><p><img src="/2022/05/10/springboot-integrate-redis/springRedis.png"></p><h2 id="Redis介绍"><a href="#Redis介绍" class="headerlink" title="Redis介绍"></a>Redis介绍</h2><p>Redis是当前比较热门的NOSQL系统之一，它是一个开源的使用ANSI c语言编写的key-value存储系统（区别于MySQL的二维表格的形式存储。）。和Memcache类似，但很大程度补偿了Memcache的不足。和Memcache一样，Redis数据都是缓存在计算机内存中，不同的是，Memcache只能将数据缓存到内存中，无法自动定期写入硬盘，这就表示，一断电或重启，内存清空，数据丢失。所以Memcache的应用场景适用于缓存无需持久化的数据。而Redis不同的是它会周期性的把更新的数据写入磁盘或者把修改操作写入追加的记录文件，实现数据的持久化。</p><p>Redis的特点：</p><ul><li><p>Redis读取的速度是110000次/s，写的速度是81000次/s；</p></li><li><p>原子 。Redis的所有操作都是原子性的，同时Redis还支持对几个操作全并后的原子性执行。</p></li><li><p>支持多种数据结构：string（字符串）；list（列表）；hash（哈希），set（集合）；zset(有序集合)</p></li><li><p>持久化，集群部署</p></li><li><p>支持过期时间，支持事务，消息订阅</p></li></ul><h2 id="引入依赖"><a href="#引入依赖" class="headerlink" title="引入依赖"></a>引入依赖</h2><p>springboot版本使用的是2.3.0</p><figure class="highlight xml hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span></span><br><span class="line">       <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span></span><br><span class="line">       <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span></span><br><span class="line">           <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.commons<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span></span><br><span class="line">           <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>commons-pool2<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span></span><br><span class="line">           <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.6.1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span></span><br><span class="line">   <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><h2 id="application-yml"><a href="#application-yml" class="headerlink" title="application.yml"></a>application.yml</h2><figure class="highlight yaml hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-attr">spring:</span></span><br><span class="line">  <span class="hljs-attr">redis:</span></span><br><span class="line">    <span class="hljs-attr">host:</span> <span class="hljs-number">192.168</span><span class="hljs-number">.234</span><span class="hljs-number">.131</span> <span class="hljs-comment">#Redis服务器地址</span></span><br><span class="line">    <span class="hljs-attr">database:</span> <span class="hljs-number">0</span><span class="hljs-comment">#Redis数据库索引（默认为0）</span></span><br><span class="line">    <span class="hljs-attr">port:</span> <span class="hljs-number">6379</span><span class="hljs-comment">#Redis服务器连接端口</span></span><br><span class="line">    <span class="hljs-attr">password:</span> <span class="hljs-number">123456</span><span class="hljs-comment">#Redis服务器连接密码（默认为空）</span></span><br><span class="line">    <span class="hljs-attr">timeout:</span> <span class="hljs-number">180000</span><span class="hljs-comment">#连接超时时间（毫秒）</span></span><br><span class="line">    <span class="hljs-attr">lettuce:</span></span><br><span class="line">      <span class="hljs-attr">pool:</span></span><br><span class="line">        <span class="hljs-attr">max-active:</span> <span class="hljs-number">20</span><span class="hljs-comment">#连接池最大连接数（使用负值表示没有限制）</span></span><br><span class="line">        <span class="hljs-attr">max-wait:</span> <span class="hljs-number">10000</span><span class="hljs-comment">#连接池最大阻塞等待时间（使用负值表示没有限制）</span></span><br><span class="line">        <span class="hljs-attr">max-idle:</span> <span class="hljs-number">5</span><span class="hljs-comment">#连接池中的最大空闲连接</span></span><br><span class="line">        <span class="hljs-attr">min-idle:</span> <span class="hljs-number">0</span><span class="hljs-comment">#连接池中的最小空闲连接</span></span><br><span class="line">      <span class="hljs-attr">shutdown-timeout:</span> <span class="hljs-number">100</span><span class="hljs-comment">#关闭超时时间</span></span><br></pre></td></tr></tbody></table></figure><h2 id="添加redis配置类"><a href="#添加redis配置类" class="headerlink" title="添加redis配置类"></a>添加redis配置类</h2><figure class="highlight java hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@EnableCaching</span></span><br><span class="line"><span class="hljs-meta">@Configuration</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="title class_">RedisConfig</span> <span class="hljs-keyword">extends</span> <span class="title class_">CachingConfigurerSupport</span> {</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@Bean</span></span><br><span class="line">    <span class="hljs-keyword">public</span> RedisTemplate&lt;String, Object&gt; <span class="title function_">redisTemplate</span><span class="hljs-params">(RedisConnectionFactory factory)</span> {</span><br><span class="line">        RedisTemplate&lt;String, Object&gt; template = <span class="hljs-keyword">new</span> <span class="title class_">RedisTemplate</span>&lt;&gt;();</span><br><span class="line">        RedisSerializer&lt;String&gt; redisSerializer = <span class="hljs-keyword">new</span> <span class="title class_">StringRedisSerializer</span>();</span><br><span class="line">        <span class="hljs-type">Jackson2JsonRedisSerializer</span> <span class="hljs-variable">jackson2JsonRedisSerializer</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="title class_">Jackson2JsonRedisSerializer</span>(Object.class);</span><br><span class="line">        <span class="hljs-type">ObjectMapper</span> <span class="hljs-variable">om</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="title class_">ObjectMapper</span>();</span><br><span class="line">        om.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.ANY);</span><br><span class="line">        om.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL);</span><br><span class="line">        jackson2JsonRedisSerializer.setObjectMapper(om);</span><br><span class="line">        template.setConnectionFactory(factory);</span><br><span class="line">        <span class="hljs-comment">//key序列化方式</span></span><br><span class="line">        template.setKeySerializer(redisSerializer);</span><br><span class="line">        <span class="hljs-comment">//value序列化</span></span><br><span class="line">        template.setValueSerializer(jackson2JsonRedisSerializer);</span><br><span class="line">        <span class="hljs-comment">//value hashmap序列化</span></span><br><span class="line">        template.setHashValueSerializer(jackson2JsonRedisSerializer);</span><br><span class="line">        <span class="hljs-keyword">return</span> template;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@Bean</span></span><br><span class="line">    <span class="hljs-keyword">public</span> CacheManager <span class="title function_">cacheManager</span><span class="hljs-params">(RedisConnectionFactory factory)</span> {</span><br><span class="line">        RedisSerializer&lt;String&gt; redisSerializer = <span class="hljs-keyword">new</span> <span class="title class_">StringRedisSerializer</span>();</span><br><span class="line">        <span class="hljs-type">Jackson2JsonRedisSerializer</span> <span class="hljs-variable">jackson2JsonRedisSerializer</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="title class_">Jackson2JsonRedisSerializer</span>(Object.class);</span><br><span class="line">        <span class="hljs-comment">//解决查询缓存转换异常的问题</span></span><br><span class="line">        <span class="hljs-type">ObjectMapper</span> <span class="hljs-variable">om</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="title class_">ObjectMapper</span>();</span><br><span class="line">        om.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.ANY);</span><br><span class="line">        om.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL);</span><br><span class="line">        jackson2JsonRedisSerializer.setObjectMapper(om);</span><br><span class="line">        <span class="hljs-comment">// 配置序列化（解决乱码的问题）,过期时间600秒</span></span><br><span class="line">        <span class="hljs-type">RedisCacheConfiguration</span> <span class="hljs-variable">config</span> <span class="hljs-operator">=</span> RedisCacheConfiguration.defaultCacheConfig()</span><br><span class="line">                .entryTtl(Duration.ofSeconds(<span class="hljs-number">600</span>))</span><br><span class="line">              .serializeKeysWith(RedisSerializationContext.SerializationPair.fromSerializer(redisSerializer))</span><br><span class="line">                .serializeValuesWith(RedisSerializationContext.SerializationPair.fromSerializer(jackson2JsonRedisSerializer))</span><br><span class="line">                .disableCachingNullValues();</span><br><span class="line">        <span class="hljs-type">RedisCacheManager</span> <span class="hljs-variable">cacheManager</span> <span class="hljs-operator">=</span> RedisCacheManager.builder(factory)</span><br><span class="line">                .cacheDefaults(config)</span><br><span class="line">                .build();</span><br><span class="line">        <span class="hljs-keyword">return</span> cacheManager;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="SpringBoot缓存注解"><a href="#SpringBoot缓存注解" class="headerlink" title="SpringBoot缓存注解"></a>SpringBoot缓存注解</h2><p><strong>@EnableCaching</strong><br>开启基于注解的缓存</p><p><strong>缓存@Cacheable</strong><br>根据方法对其返回结果进行缓存，下次请求时，如果缓存存在，则直接读取缓存数据返回；如果缓存不存在，则执行方法，并把返回的结果存入缓存中。一般用在查询方法上。属性值如下：</p><table><thead><tr><th align="left">属性名</th><th align="left">解释</th></tr></thead><tbody><tr><td align="left">value</td><td align="left">缓存名，必填，它指定了你的缓存存放在哪块命名空间</td></tr><tr><td align="left">cacheNames</td><td align="left">与 value 差不多，二选一即可</td></tr><tr><td align="left">key</td><td align="left">缓存的 key，可以为空，如果指定要按照 <strong>SpEL</strong> 表达 式编写，如果不指定，则缺省按照方法的所有参数进行组合</td></tr><tr><td align="left">keyGenerator</td><td align="left">缓存数据时key生成策略，与key属性互斥</td></tr><tr><td align="left">cacheManager</td><td align="left">指定自定义CacheManager的名称，与cacheResolver属性互斥</td></tr><tr><td align="left">cacheResolver</td><td align="left">指定自定义的CacheResolver名称</td></tr><tr><td align="left">condition</td><td align="left">缓存的条件，可以为空，表示方法结果始终被缓存。而使用 <strong>SpEL</strong> 编写，返回 true 或者 false，只有为 true 才进行缓存/清除缓存，在<strong>调用方法之前之后</strong>都能判断</td></tr><tr><td align="left">unless</td><td align="left">用于否决缓存的，不像condition，该表达式只在<strong>方法执行之后</strong>判断，此时可以拿到返回值result进行判 断。条件为true不会缓存，fasle才缓存</td></tr><tr><td align="left">sync</td><td align="left">是否同步，默认是false，如果为true，unless将不受支持</td></tr></tbody></table><p><strong>@CachePut</strong><br>使用该注解标志的方法，每次都会执行，并将结果存入指定的缓存中。其他方法可以直接从响应的缓存中读取缓存数据，而不需要再去查询数据库。一般用在新增和更新方法上。属性值如下：</p><table><thead><tr><th align="left">属性名</th><th align="left">解释</th></tr></thead><tbody><tr><td align="left">value</td><td align="left">缓存名，必填，它指定了你的缓存存放在哪块命名空间</td></tr><tr><td align="left">cacheNames</td><td align="left">与 value 差不多，二选一即可</td></tr><tr><td align="left">key</td><td align="left">缓存的 key，可以为空，如果指定要按照 <strong>SpEL</strong> 表达式编写，如果不指定，则缺省按照方法的所有参数进行组合</td></tr><tr><td align="left">keyGenerator</td><td align="left">缓存数据时key生成策略，与key属性互斥</td></tr><tr><td align="left">cacheManager</td><td align="left">指定自定义CacheManager的名称，与cacheResolver属性互斥</td></tr><tr><td align="left">cacheResolver</td><td align="left">指定自定义的CacheResolver名称</td></tr><tr><td align="left">condition</td><td align="left">缓存的条件，可以为空，表示方法结果始终被缓存。而使用<strong>SpEL</strong> 编写，返回 true 或者 false，只有为 true 才进行缓存/清除缓存，在<strong>调用方法之前之后</strong>都能判断</td></tr><tr><td align="left">unless</td><td align="left">用于否决缓存的，不像condition，该表达式只在<strong>方法执行之后</strong>判断，此时可以拿到返回值result进行判 断。条件为true不会缓存，fasle才缓存</td></tr></tbody></table><p><strong>@CacheEvict</strong><br>使用该注解标志的方法，会清空指定的缓存。一般用在更新或者删除方法上，属性值如下：</p><table><thead><tr><th align="left">属性名</th><th align="left">解释</th></tr></thead><tbody><tr><td align="left">value</td><td align="left">缓存名，必填，它指定了你的缓存存放在哪块命名空间</td></tr><tr><td align="left">cacheNames</td><td align="left">与 value 差不多，二选一即可</td></tr><tr><td align="left">key</td><td align="left">缓存的 key，可以为空，如果指定要按照 <strong>SpEL</strong> 表达式编写，如果不指定，则缺省按照方法的所有参数进行组合</td></tr><tr><td align="left">keyGenerator</td><td align="left">缓存数据时key生成策略，与key属性互斥</td></tr><tr><td align="left">cacheManager</td><td align="left">指定自定义CacheManager的名称，与cacheResolver属性互斥</td></tr><tr><td align="left">cacheResolver</td><td align="left">指定自定义的CacheResolver名称</td></tr><tr><td align="left">condition</td><td align="left">缓存的条件，可以为空，表示方法结果始终被缓存。而使用 <strong>SpEL</strong> 编写，返回 true 或者 false，只有为 true 才进行缓存/清除缓存，在<strong>调用方法之前之后</strong>都能判断</td></tr><tr><td align="left">allEntries</td><td align="left">是否清空所有缓存内容，缺省为 false。如果指定为 true，则方法调用后将立即清空所有缓存。<br><strong>注意不允许将此参数设置为true并指定一个key</strong></td></tr><tr><td align="left">beforeInvocation</td><td align="left">是否在方法执行前就清空，缺省为 false。缺省情况下，如果方法执行<strong>抛出异常</strong>，则不会清空缓存。如果指定 为 true，则在方法还没有执行的时候就清空缓存。</td></tr></tbody></table><p><strong>@Caching</strong><br>不同或相同类型的缓存注释的组注释，用于定制复杂的缓存规则。</p><table><thead><tr><th align="left">属性名</th><th align="left">解释</th></tr></thead><tbody><tr><td align="left">cacheable</td><td align="left">默认为空，可以定义一个或多个@Cacheable</td></tr><tr><td align="left">put</td><td align="left">默认为空，可以定义一个或多个@CachePut</td></tr><tr><td align="left">evict</td><td align="left">默认为空，可以定义一个或多个@CacheEvict</td></tr></tbody></table><p><strong>@CacheConfig</strong><br>用于标注在类上，可以存放该类中所有缓存的公有属性，比如设置缓存的名字。</p><table><thead><tr><th align="left">属性名</th><th align="left">解释</th></tr></thead><tbody><tr><td align="left">cacheNames</td><td align="left">与 value 差不多，二选一即可</td></tr><tr><td align="left">keyGenerator</td><td align="left">缓存数据时key生成策略，与key属性互斥</td></tr><tr><td align="left">cacheManager</td><td align="left">指定自定义CacheManager的名称，如果没有设置cacheResolver，并且在类中的缓存注解未设置缓存解析器和缓存管理器，则使用该管理器而不是默认值。</td></tr><tr><td align="left">cacheResolver</td><td align="left">指定自定义CacheResolver的名称，如果在类中的缓存注解没有设置解析器和缓存管理器，则使用此解析器而不是默认值。</td></tr></tbody></table><h3 id="SpEL"><a href="#SpEL" class="headerlink" title="SpEL"></a>SpEL</h3><table><thead><tr><th align="left">名字</th><th align="left">位置</th><th align="left">描述</th><th align="left">示例</th></tr></thead><tbody><tr><td align="left">methodName</td><td align="left">root object</td><td align="left">当前被调用的方法名</td><td align="left">#root.methodName</td></tr><tr><td align="left">method</td><td align="left">root object</td><td align="left">当前被调用的方法</td><td align="left">#root.method.name</td></tr><tr><td align="left">target</td><td align="left">root object</td><td align="left">当前被调用的目标对象</td><td align="left">#root.target</td></tr><tr><td align="left">targetClass</td><td align="left">root object</td><td align="left">当前被调用的目标对象类</td><td align="left">#root.targetClass</td></tr><tr><td align="left">args</td><td align="left">root object</td><td align="left">当前被调用的方法的参数列表</td><td align="left">#root.args[0] 表示参数列表第一个参数</td></tr><tr><td align="left">caches</td><td align="left">root object</td><td align="left">当前方法调用使用的缓存列表（如@Cacheable(value={“cache1”, “cache2”})），<br>则有两个cache</td><td align="left">#root.caches[0].name，取缓存列<br>表中第一个缓存名称</td></tr><tr><td align="left">argument name</td><td align="left">evaluation context(上下文)</td><td align="left">方法参数的名字. 可以直接 #参数名 ，也可以使用 #p0或#a0 的 形式，0代表参数的索引；</td><td align="left">#id、#p0,#a0</td></tr><tr><td align="left">result</td><td align="left">evaluation context</td><td align="left">方法执行后的返回值（仅当方法执行之后的判断有效，如 ‘unless’，’cache put’的表达式 ’cache evict’的属性beforeInvocation=false</td><td align="left">#result，#result.id(返回结果的属性名)</td></tr></tbody></table><h2 id="使用RestTemplate操作redis"><a href="#使用RestTemplate操作redis" class="headerlink" title="使用RestTemplate操作redis"></a>使用RestTemplate操作redis</h2><p>1.redisTemplate.opsForValue();//操作字符串 </p><p>2.redisTemplate.opsForHash();//操作hash </p><p>3.redisTemplate.opsForList();//操作list </p><p>4.redisTemplate.opsForSet();//操作set </p><p>5.redisTemplate.opsForZSet();//操作有序set </p><p>其他操作不一一列举</p><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>首先我们先编写一个小Demo，我持久化层使用的是mybatis,这里代码很简单，就直接越过。</p><p><img src="https://img-blog.csdnimg.cn/20200920212145547.png#pic_left"><br>然后看一下我们service层代码，在方法上添加了@Cacheable注解</p><figure class="highlight java hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Service</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="title class_">DepartmentService</span> {</span><br><span class="line">    <span class="hljs-meta">@Autowired</span></span><br><span class="line">    <span class="hljs-keyword">private</span> DepartmentMapper departmentMapper;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@Cacheable(cacheNames = "dep",key = "#id")</span></span><br><span class="line">    <span class="hljs-keyword">public</span> Department <span class="title function_">getDep</span><span class="hljs-params">(Integer id)</span>{</span><br><span class="line">        <span class="hljs-type">Department</span> <span class="hljs-variable">byId</span> <span class="hljs-operator">=</span> departmentMapper.getById(id);</span><br><span class="line">        <span class="hljs-keyword">return</span> byId;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>编写测试方法，看打印的日志结果</p><figure class="highlight java hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Test</span></span><br><span class="line">   <span class="hljs-keyword">void</span> <span class="title function_">contextLoads</span><span class="hljs-params">()</span> {</span><br><span class="line">       <span class="hljs-type">Department</span> <span class="hljs-variable">dep</span> <span class="hljs-operator">=</span> departmentService.getDep(<span class="hljs-number">1</span>);</span><br><span class="line">       System.out.println(dep);</span><br><span class="line">   }</span><br></pre></td></tr></tbody></table></figure><p>第一次执行从数据库里查数据，日志打印出SQL语句<br><img src="https://img-blog.csdnimg.cn/20200920212903368.png#pic_left"><br>第二次执行，日志没有打印SQL语句，说明是从redis缓存取数据<br><img src="https://img-blog.csdnimg.cn/20200920213756625.png?t_70#pic_left"><br>而我们也可以打开Redis Desktop Manager查看，数据的确存进缓存中了<br><img src="https://img-blog.csdnimg.cn/20200920213949479.png?t_70#pic_left"></p></body></html>]]></content>
    
    
    <summary type="html">&lt;!--redis--&gt;&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt;</summary>
    
    
    
    <category term="springboot" scheme="https://relive27.github.io/categories/springboot/"/>
    
    
    <category term="redis" scheme="https://relive27.github.io/tags/redis/"/>
    
    <category term="SpringBoot" scheme="https://relive27.github.io/tags/SpringBoot/"/>
    
  </entry>
  
  <entry>
    <title>Spring项目的resources目录下的文件读取</title>
    <link href="https://relive27.github.io/2022/05/09/spring-read-resource/"/>
    <id>https://relive27.github.io/2022/05/09/spring-read-resource/</id>
    <published>2022-05-09T12:50:16.000Z</published>
    <updated>2022-06-19T14:09:06.032Z</updated>
    
    <content type="html"><![CDATA[<!-- SpringBoot --><html><head></head><body><span id="more"></span><h3 id="src-x2F-main-x2F-resources和src-x2F-test-x2F-resources下的资源读取方式"><a href="#src-x2F-main-x2F-resources和src-x2F-test-x2F-resources下的资源读取方式" class="headerlink" title="src/main/resources和src/test/resources下的资源读取方式"></a>src/main/resources和src/test/resources下的资源读取方式</h3><p><strong>1.</strong> 一般maven会将spring工程编译到target文件夹下，/target/classes就是其根目录。而src/main/resources下的文件被复制到了这个classes文件夹下。</p><p><strong>2.</strong> maven会将src/test/java文件夹下的代码编译到target/test-classes文件夹下。同样的，如果src/test/resources下有资源文件的话，就复制到target/test-classes文件夹下。</p><p>测试代码运行时，优先使用test-classes文件夹下的资源文件，如果不存在，再使用classes文件夹下的资源文件。</p><p><strong>前两种底层代码都是通过类加载器读取流</strong> </p><p><strong>1.</strong> 使用<strong>org.springframework.core.io.ClassPathResource</strong>读取，开发环境和生产环境(Linux下jar包运行读取)都能读取。</p><figure class="highlight java hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Resource resource=<span class="hljs-keyword">new</span> <span class="title class_">ClassPathResource</span>(<span class="hljs-string">"3.png"</span>);</span><br><span class="line"><span class="hljs-type">InputStream</span> <span class="hljs-variable">fis</span> <span class="hljs-operator">=</span> resource.getInputStream();</span><br><span class="line">OutputStream fos=<span class="hljs-keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="hljs-string">"E://3.png"</span>);</span><br><span class="line"><span class="hljs-type">int</span> len=<span class="hljs-number">0</span>;</span><br><span class="line"><span class="hljs-type">byte</span>[] buf=<span class="hljs-keyword">new</span> <span class="title class_">byte</span>[<span class="hljs-number">1024</span>];</span><br><span class="line"><span class="hljs-keyword">while</span>((len=fis.read(buf,<span class="hljs-number">0</span>,buf.length))!=-<span class="hljs-number">1</span>){</span><br><span class="line">    fos.write(buf,<span class="hljs-number">0</span>,len);</span><br><span class="line">}</span><br><span class="line">fos.close();</span><br><span class="line">fis.close();</span><br></pre></td></tr></tbody></table></figure><p><strong>2.</strong> 使用流的方式来读取，两种方式，开发环境和生产环境(Linux下jar包运行读取)都能读取。</p><p>方式一：</p><figure class="highlight java hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-type">InputStream</span> <span class="hljs-variable">fis</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.getClass().getResourceAsStream(<span class="hljs-string">"/3.png"</span>);</span><br><span class="line">OutputStream fos=<span class="hljs-keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="hljs-string">"E://3.png"</span>);</span><br><span class="line"><span class="hljs-type">int</span> len=<span class="hljs-number">0</span>;</span><br><span class="line"><span class="hljs-type">byte</span>[] buf=<span class="hljs-keyword">new</span> <span class="title class_">byte</span>[<span class="hljs-number">1024</span>];</span><br><span class="line"><span class="hljs-keyword">while</span>((len=fis.read(buf,<span class="hljs-number">0</span>,buf.length))!=-<span class="hljs-number">1</span>){</span><br><span class="line">    fos.write(buf,<span class="hljs-number">0</span>,len);</span><br><span class="line">}</span><br><span class="line">fos.close();</span><br><span class="line">fis.close();</span><br></pre></td></tr></tbody></table></figure><p>方式二：</p><figure class="highlight java hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-type">InputStream</span> <span class="hljs-variable">fis</span> <span class="hljs-operator">=</span> Thread.currentThread().getContextClassLoader().getResourceAsStream(<span class="hljs-string">"/3.png"</span>);</span><br><span class="line">OutputStream fos=<span class="hljs-keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="hljs-string">"E://3.png"</span>);</span><br><span class="line"><span class="hljs-type">int</span> len=<span class="hljs-number">0</span>;</span><br><span class="line"><span class="hljs-type">byte</span>[] buf=<span class="hljs-keyword">new</span> <span class="title class_">byte</span>[<span class="hljs-number">1024</span>];</span><br><span class="line"><span class="hljs-keyword">while</span>((len=fis.read(buf,<span class="hljs-number">0</span>,buf.length))!=-<span class="hljs-number">1</span>){</span><br><span class="line">    fos.write(buf,<span class="hljs-number">0</span>,len);</span><br><span class="line">}</span><br><span class="line">fos.close();</span><br><span class="line">fis.close();</span><br></pre></td></tr></tbody></table></figure><p><strong>3.</strong> 使用<strong>org.springframework.core.io.ResourceLoader</strong> 读取，开发环境和生产环境(Linux下jar包运行读取)都能读取。</p><figure class="highlight java hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Autowired</span></span><br><span class="line">ResourceLoader resourceLoader;</span><br><span class="line"></span><br><span class="line"><span class="hljs-meta">@Test</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="title function_">resourceLoaderTest</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException {</span><br><span class="line">    <span class="hljs-type">Resource</span> <span class="hljs-variable">resource</span> <span class="hljs-operator">=</span> resourceLoader.getResource(<span class="hljs-string">"classpath:3.png"</span>);</span><br><span class="line">    <span class="hljs-type">InputStream</span> <span class="hljs-variable">fis</span> <span class="hljs-operator">=</span> resource.getInputStream();</span><br><span class="line">    OutputStream fos=<span class="hljs-keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="hljs-string">"E://3.png"</span>);</span><br><span class="line">    <span class="hljs-type">int</span> len=<span class="hljs-number">0</span>;</span><br><span class="line">    <span class="hljs-type">byte</span>[] buf=<span class="hljs-keyword">new</span> <span class="title class_">byte</span>[<span class="hljs-number">1024</span>];</span><br><span class="line">    <span class="hljs-keyword">while</span>((len=fis.read(buf,<span class="hljs-number">0</span>,buf.length))!=-<span class="hljs-number">1</span>){</span><br><span class="line">        fos.write(buf,<span class="hljs-number">0</span>,len);</span><br><span class="line">    }</span><br><span class="line">    fos.close();</span><br><span class="line">    fis.close();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><strong>4.</strong> 使用<strong>File file=new File(“src/main/resources/file.txt”);</strong> 读取，只能在开发环境中读取，不能再生产环境中读取(Linux下jar包运行读取)。</p><figure class="highlight java hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">File file=<span class="hljs-keyword">new</span> <span class="title class_">File</span>(<span class="hljs-string">"src/main/resources/3.png"</span>);</span><br><span class="line">InputStream fis=<span class="hljs-keyword">new</span> <span class="title class_">FileInputStream</span>(file);</span><br><span class="line">OutputStream fos=<span class="hljs-keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="hljs-string">"E://3.png"</span>);</span><br><span class="line"><span class="hljs-type">int</span> len=<span class="hljs-number">0</span>;</span><br><span class="line"><span class="hljs-type">byte</span>[] buf=<span class="hljs-keyword">new</span> <span class="title class_">byte</span>[<span class="hljs-number">1024</span>];</span><br><span class="line"><span class="hljs-keyword">while</span> ((len=fis.read(buf,<span class="hljs-number">0</span>,buf.length))!=-<span class="hljs-number">1</span>){</span><br><span class="line">  fos.write(buf,<span class="hljs-number">0</span>,len);</span><br><span class="line">  System.out.println(<span class="hljs-string">"---"</span>);</span><br><span class="line">}</span><br><span class="line">fos.close();</span><br><span class="line">fis.close();</span><br></pre></td></tr></tbody></table></figure><p><strong>5.</strong> 使用<strong>org.springframework.util.ResourceUtils</strong> 读取，只能在开发环境中读取，不能再生产环境中读取(Linux下jar包运行读取)。</p><figure class="highlight java hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-type">File</span> <span class="hljs-variable">file</span> <span class="hljs-operator">=</span> ResourceUtils.getFile(<span class="hljs-string">"src/main/resources/3.png"</span>);</span><br><span class="line">InputStream fis=<span class="hljs-keyword">new</span> <span class="title class_">FileInputStream</span>(file);</span><br><span class="line">OutputStream fos=<span class="hljs-keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="hljs-string">"E://3.png"</span>);</span><br><span class="line"><span class="hljs-type">int</span> len=<span class="hljs-number">0</span>;</span><br><span class="line"><span class="hljs-type">byte</span>[] buf=<span class="hljs-keyword">new</span> <span class="title class_">byte</span>[<span class="hljs-number">1024</span>];</span><br><span class="line"><span class="hljs-keyword">while</span>((len=fis.read(buf,<span class="hljs-number">0</span>,buf.length))!=-<span class="hljs-number">1</span>){</span><br><span class="line">    fos.write(buf,<span class="hljs-number">0</span>,len);</span><br><span class="line">}</span><br><span class="line">fos.close();</span><br><span class="line">fis.close();</span><br></pre></td></tr></tbody></table></figure><h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><p>与往常一样，本文中使用的源代码可<a href="https://github.com/ReLive27/spring-boot-sample/blob/master/spring-static-resource/src/main/java/com/relive/ResourceFileReader.java">在 GitHub 上</a>获得。</p></body></html>]]></content>
    
    
    <summary type="html">&lt;!-- SpringBoot --&gt;&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt;</summary>
    
    
    
    <category term="springboot" scheme="https://relive27.github.io/categories/springboot/"/>
    
    
    <category term="springboot" scheme="https://relive27.github.io/tags/springboot/"/>
    
  </entry>
  
  <entry>
    <title>注解@PathVariable、@RequestParam、@RequestBody、@RequestHeader讲解</title>
    <link href="https://relive27.github.io/2022/05/09/spring-mvc-annotation/"/>
    <id>https://relive27.github.io/2022/05/09/spring-mvc-annotation/</id>
    <published>2022-05-09T04:13:37.000Z</published>
    <updated>2022-05-09T04:42:36.746Z</updated>
    
    <content type="html"><![CDATA[<!-- SpringMVC --><html><head></head><body><span id="more"></span><h4 id="PathVariable"><a href="#PathVariable" class="headerlink" title="@PathVariable"></a>@PathVariable</h4><p>绑定请求参数，当@RequestMapping(value=”/get/{id}”），可以获取url格式/get/{id}中{id}的值</p><table><thead><tr><th align="left">属性</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">value</td><td align="left">指定request参数名</td></tr><tr><td align="left">name</td><td align="left">指定request参数名（与value二选一）</td></tr><tr><td align="left">required</td><td align="left">是否需要该参数。 默认为true，如果请求中缺少参数，则会引发<strong>异常</strong></td></tr></tbody></table><p>当url为 get/{id}/{name}</p><figure class="highlight java hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@RequestMapping("/get/{id}/{name}")</span></span><br><span class="line"><span class="hljs-keyword">public</span> String <span class="title function_">get</span><span class="hljs-params">(<span class="hljs-meta">@PathVariable</span> Integer id,<span class="hljs-meta">@PathVariable</span> String name)</span></span><br></pre></td></tr></tbody></table></figure><hr><p>当需要对url变量进行更加精确的定义时，可以定义正则表达式进行更精确地控制，定义语法是{变量名: 正则表达式}</p><figure class="highlight plaintext hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@RequestMapping("/get/{name:[a-zA-Z0-9]+}")</span><br><span class="line">public String get(@PathVariable String name)</span><br></pre></td></tr></tbody></table></figure><p>如此设置URL变量规则后，不合法的URL则不会被处理，直接由SpringMVC框架返回404NotFound。</p><h4 id="RequestParam"><a href="#RequestParam" class="headerlink" title="@RequestParam"></a>@RequestParam</h4><p>绑定来自请求url中的参数，可以获取url格式：?username=”zhangsan”。</p><table><thead><tr><th align="left">属性</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">value</td><td align="left">指定request参数名</td></tr><tr><td align="left">name</td><td align="left">指定request参数名（与value二选一）</td></tr><tr><td align="left">required</td><td align="left">是否需要该参数。 默认为true，如果请求中缺少参数，则会引发<strong>异常</strong></td></tr><tr><td align="left">defaultValue</td><td align="left">未提供request参数或具有空值时用作后备的默认值,当设置默认值时，required隐式的设为了false</td></tr></tbody></table><p>如果在传递参数时url是?userName=zhangsan&amp;userName=wangwu，即两个同名参数，后台可以用以下方法接收：</p><figure class="highlight java hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> String <span class="title function_">getUserName</span><span class="hljs-params">(<span class="hljs-meta">@RequestParam(value="userName")</span> String []  userNames)</span></span><br><span class="line"><span class="hljs-comment">//或者是</span></span><br><span class="line"><span class="hljs-keyword">public</span> String <span class="title function_">getUserName</span><span class="hljs-params">(<span class="hljs-meta">@RequestParam(value="list")</span> List&lt;String&gt; list)</span>  </span><br></pre></td></tr></tbody></table></figure><h5 id="Get-x2F-POST请求测试"><a href="#Get-x2F-POST请求测试" class="headerlink" title="Get/POST请求测试"></a>Get/POST请求测试</h5><figure class="highlight java hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> String <span class="title function_">get</span><span class="hljs-params">(<span class="hljs-meta">@RequestParam</span> Map map)</span></span><br><span class="line"><span class="hljs-comment">//在url中？后面添加参数可以接收</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">public</span> String <span class="title function_">get</span><span class="hljs-params">(<span class="hljs-meta">@RequestParam</span> String id)</span></span><br><span class="line"><span class="hljs-comment">//在url中？后面添加参数可以接收</span></span><br><span class="line">  </span><br><span class="line"><span class="hljs-keyword">public</span> String <span class="title function_">get</span><span class="hljs-params">(<span class="hljs-meta">@RequestParam</span> Object object)</span></span><br><span class="line"><span class="hljs-comment">//参数接收不到</span></span><br></pre></td></tr></tbody></table></figure><h4 id="RequestBody"><a href="#RequestBody" class="headerlink" title="@RequestBody"></a>@RequestBody</h4><p>绑定来自HTTP<strong>请求体</strong> 的参数</p><p><strong>@RequestBody用来处理 Content-Type 为 application/json、application/xml编码的内容</strong></p><table><thead><tr><th align="left">属性</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">required</td><td align="left">是否需要该参数。 默认为true，如果请求中缺少参数，则会引发<strong>异常</strong></td></tr></tbody></table><h5 id="GET-x2F-POST-请求测试"><a href="#GET-x2F-POST-请求测试" class="headerlink" title="GET/POST 请求测试"></a>GET/POST 请求测试</h5><figure class="highlight java hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> String <span class="title function_">get</span><span class="hljs-params">(<span class="hljs-meta">@RequestBody</span> Map map)</span></span><br><span class="line"><span class="hljs-comment">//json参数可以接收</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">public</span> String <span class="title function_">get</span><span class="hljs-params">(<span class="hljs-meta">@RequestBody</span> String id)</span></span><br><span class="line"><span class="hljs-comment">//json参数可以接收,但是字符串接收的是整个json格式的字符串,如打印：{"id":3,"name":"ddd"}</span></span><br><span class="line">  </span><br><span class="line"><span class="hljs-keyword">public</span> String <span class="title function_">get</span><span class="hljs-params">(<span class="hljs-meta">@RequestBody</span> Object object)</span></span><br><span class="line"><span class="hljs-comment">//json参数可以接收</span></span><br></pre></td></tr></tbody></table></figure><p>指定实体类中的属性对应json中的key值@JsonProperty、@JsonAlias</p><figure class="highlight java hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Data</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="title class_">Employee</span> {</span><br><span class="line">    <span class="hljs-meta">@JsonProperty(value = "ids")</span> <span class="hljs-comment">//json中的key为ids可以识别，key为id不能识别</span></span><br><span class="line">    <span class="hljs-keyword">private</span> String id;</span><br><span class="line">    <span class="hljs-meta">@JsonAlias(value = {"NAME","ii"})</span> <span class="hljs-comment">//json中的key为NAME、ii、name都能识别</span></span><br><span class="line">    <span class="hljs-keyword">private</span> String name;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="RequestHeader"><a href="#RequestHeader" class="headerlink" title="@RequestHeader"></a>@RequestHeader</h4><p>从Http请求头中提取指定的某个请求头。</p><table><thead><tr><th align="left">属性</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">value</td><td align="left">指定请求头中的key</td></tr><tr><td align="left">name</td><td align="left">指定请求头中的key（与value二选一）</td></tr><tr><td align="left">required</td><td align="left">是否需要该参数。 默认为true，如果请求中缺少参数，则会引发<strong>异常</strong></td></tr><tr><td align="left">defaultValue</td><td align="left">未提供request参数或具有空值时用作后备的默认值,当设置默认值时，required隐式的设为了false</td></tr></tbody></table><figure class="highlight java hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> String <span class="title function_">get</span><span class="hljs-params">(<span class="hljs-meta">@RequestHeader(value = "Content-Type")</span> String contextType)</span>{}</span><br></pre></td></tr></tbody></table></figure></body></html>]]></content>
    
    
    <summary type="html">&lt;!-- SpringMVC --&gt;&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt;</summary>
    
    
    
    <category term="springboot" scheme="https://relive27.github.io/categories/springboot/"/>
    
    
    <category term="springmvc" scheme="https://relive27.github.io/tags/springmvc/"/>
    
  </entry>
  
</feed>
