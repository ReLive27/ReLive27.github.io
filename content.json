{"pages":[{"title":"weekly","text":"","link":"/weekly/index.html"}],"posts":[{"title":"自定义OAuth2授权同意页面","text":"自定义OAuth2授权同意页面前文我们已经简单的介绍了如何搭建授权服务器，下面将继续介绍如何自定义OAuth2授权同意页面。 如果你已经无法容忍Spring Authorization Server 默认丑陋的授权同意页面，那么你可以继续阅读本文，逐步创建一个令自己满意的授权同意页面。 OAuth2授权服务器实现从创建一个授权服务器开始。 maven依赖123456789101112131415161718192021222324&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-security&lt;/artifactId&gt; &lt;version&gt;2.6.7&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.security&lt;/groupId&gt; &lt;artifactId&gt;spring-security-oauth2-authorization-server&lt;/artifactId&gt; &lt;version&gt;0.3.1&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;version&gt;2.6.7&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt; &lt;version&gt;2.6.7&lt;/version&gt;&lt;/dependency&gt; 配置首先我们为授权服务器配置端口8080: 12server: port: 8080 之后我们创建一个AuthorizationServerConfig配置类，在此类中我们将创建OAuth2授权服务器所需特定的Bean。首先指定我们授权同意页面/oauth2/consent uri替换原有默认实现。 123456789101112131415161718192021222324252627@Configuration(proxyBeanMethods = false)public class AuthorizationServerConfig { private static final String CUSTOM_CONSENT_PAGE_URI = \"/oauth2/consent\"; @Bean @Order(Ordered.HIGHEST_PRECEDENCE) public SecurityFilterChain authorizationServerSecurityFilterChain(HttpSecurity http) throws Exception { OAuth2AuthorizationServerConfigurer&lt;HttpSecurity&gt; authorizationServerConfigurer = new OAuth2AuthorizationServerConfigurer&lt;&gt;(); //定义授权同意页面 authorizationServerConfigurer.authorizationEndpoint(authorizationEndpoint -&gt; authorizationEndpoint.consentPage(CUSTOM_CONSENT_PAGE_URI)); RequestMatcher endpointsMatcher = authorizationServerConfigurer .getEndpointsMatcher(); http.requestMatcher(endpointsMatcher) .authorizeRequests(authorizeRequests -&gt; authorizeRequests.anyRequest().authenticated() ) .csrf(csrf -&gt; csrf.ignoringRequestMatchers(endpointsMatcher)) .apply(authorizationServerConfigurer); return http.exceptionHandling(exceptions -&gt; exceptions. authenticationEntryPoint(new LoginUrlAuthenticationEntryPoint(\"/login\"))).build(); } //...} 接下来我们使用RegisteredClient构建器类型创建一个OAuth2客户端，并将它存储在缓存中。 123456789101112131415161718192021222324252627282930313233@Bean public RegisteredClientRepository registeredClientRepository() { RegisteredClient registeredClient = RegisteredClient.withId(UUID.randomUUID().toString()) .clientId(\"relive-client\") .clientSecret(\"{noop}relive-client\") .clientName(\"ReLive27\") .clientAuthenticationMethods(s -&gt; { s.add(ClientAuthenticationMethod.CLIENT_SECRET_POST); s.add(ClientAuthenticationMethod.CLIENT_SECRET_BASIC); }) .authorizationGrantType(AuthorizationGrantType.AUTHORIZATION_CODE) .authorizationGrantType(AuthorizationGrantType.REFRESH_TOKEN) .authorizationGrantType(AuthorizationGrantType.CLIENT_CREDENTIALS) .authorizationGrantType(AuthorizationGrantType.PASSWORD) .redirectUri(\"http://127.0.0.1:8070/login/oauth2/code/messaging-client-authorization-code\") .scope(OidcScopes.PROFILE) .scope(\"message.read\") .scope(\"message.write\") .clientSettings(ClientSettings.builder() .requireAuthorizationConsent(true) .requireProofKey(false) .build()) .tokenSettings(TokenSettings.builder() .accessTokenFormat(OAuth2TokenFormat.SELF_CONTAINED) .idTokenSignatureAlgorithm(SignatureAlgorithm.RS256) .accessTokenTimeToLive(Duration.ofSeconds(30 * 60)) .refreshTokenTimeToLive(Duration.ofSeconds(60 * 60)) .reuseRefreshTokens(true) .build()) .build(); return new InMemoryRegisteredClientRepository(registeredClient); } 其余配置将不再赘述，可以参考之前将JWT与Spring Security OAuth2结合使用文章。 接下来将创建一个授权页面控制器，并将所需参数传递给Model： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768@Controller@RequiredArgsConstructorpublic class AuthorizationConsentController { private final RegisteredClientRepository registeredClientRepository; @GetMapping(value = \"/oauth2/consent\") public String consent(Principal principal, Model model, @RequestParam(OAuth2ParameterNames.CLIENT_ID) String clientId, @RequestParam(OAuth2ParameterNames.SCOPE) String scope, @RequestParam(OAuth2ParameterNames.STATE) String state) { Set&lt;String&gt; scopesToApprove = new LinkedHashSet&lt;&gt;(); RegisteredClient registeredClient = this.registeredClientRepository.findByClientId(clientId); Set&lt;String&gt; scopes = registeredClient.getScopes(); for (String requestedScope : StringUtils.delimitedListToStringArray(scope, \" \")) { if (scopes.contains(requestedScope)) { scopesToApprove.add(requestedScope); } } model.addAttribute(\"clientId\", clientId); model.addAttribute(\"clientName\", registeredClient.getClientName()); model.addAttribute(\"state\", state); model.addAttribute(\"scopes\", withDescription(scopesToApprove)); model.addAttribute(\"principalName\", principal.getName()); model.addAttribute(\"redirectUri\", registeredClient.getRedirectUris().iterator().next()); return \"consent\"; } private static Set&lt;ScopeWithDescription&gt; withDescription(Set&lt;String&gt; scopes) { Set&lt;ScopeWithDescription&gt; scopeWithDescriptions = new LinkedHashSet&lt;&gt;(); for (String scope : scopes) { scopeWithDescriptions.add(new ScopeWithDescription(scope)); } return scopeWithDescriptions; } public static class ScopeWithDescription { private static final String DEFAULT_DESCRIPTION = \"我们无法提供有关此权限的信息\"; private static final Map&lt;String, String&gt; scopeDescriptions = new HashMap&lt;&gt;(); static { scopeDescriptions.put( \"profile\", \"验证您的身份\" ); scopeDescriptions.put( \"message.read\", \"了解您可以访问哪些权限\" ); scopeDescriptions.put( \"message.write\", \"代表您行事\" ); } public final String scope; public final String description; ScopeWithDescription(String scope) { this.scope = scope; this.description = scopeDescriptions.getOrDefault(scope, DEFAULT_DESCRIPTION); } }} 之后让我们定义html页面，这里使用thymeleaf模版引擎： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1, shrink-to-fit=no\"&gt; &lt;link rel=\"stylesheet\" href=\"https://stackpath.bootstrapcdn.com/bootstrap/4.5.2/css/bootstrap.min.css\" integrity=\"sha384-JcKb8q3iqJ61gNV9KGb8thSsNjpSL0n8PARn9HuZOnIxN0hoP+VmmDGMN5t9UJ0Z\" crossorigin=\"anonymous\"&gt; &lt;title&gt;Custom consent page - Consent required&lt;/title&gt; &lt;style&gt; body { background-color: #f6f8fa; } #submit-consent { width: 45%; float: right; height: 40px; font-size: 18px; border-color: #cccccc; margin-right: 3%; } #cancel-consent { width: 45%; height: 40px; font-size: 18px; color: black; background-color: #cccccc; border-color: #cccccc; float: left; margin-left: 3%; } &lt;/style&gt; &lt;script&gt; function cancelConsent() { document.consent_form.reset(); document.consent_form.submit(); } &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;div style=\"width: 500px;height: 600px;margin: 100px auto\"&gt; &lt;h5 style=\"text-align: center\"&gt;&lt;b th:text=\"${clientName}\"&gt;&lt;/b&gt;希望获得以下许可：&lt;/h5&gt; &lt;div style=\"width: 100%;height: 500px;border: #cccccc 1px solid;border-radius: 10px\"&gt; &lt;form name=\"consent_form\" method=\"post\" action=\"/oauth2/authorize\"&gt; &lt;input type=\"hidden\" name=\"client_id\" th:value=\"${clientId}\"&gt; &lt;input type=\"hidden\" name=\"state\" th:value=\"${state}\"&gt; &lt;div th:each=\"scope: ${scopes}\" class=\"form-group form-check py-1\" style=\"margin-left: 5%\"&gt; &lt;input class=\"form-check-input\" type=\"checkbox\" name=\"scope\" th:value=\"${scope.scope}\" th:id=\"${scope.scope}\" checked&gt; &lt;label class=\"form-check-label font-weight-bold\" th:for=\"${scope.scope}\" th:text=\"${scope.scope}=='profile'?(${scope.description}+'('+${principalName}+')'):${scope.description}\"&gt;&lt;/label&gt; &lt;/div&gt; &lt;hr style=\"width: 90%\"&gt; &lt;p style=\"margin-left: 5%\"&gt;&lt;b th:text=\"${clientName}\"&gt;&lt;/b&gt;尚未安装在您有权访问的任何账户上。&lt;/p&gt; &lt;hr style=\"width: 90%\"&gt; &lt;div class=\"form-group pt-3\" style=\"width: 100%;height: 80px;\"&gt; &lt;button class=\"btn btn-primary btn-lg\" type=\"submit\" id=\"submit-consent\"&gt; 授权同意 &lt;/button&gt; &lt;button class=\"btn btn-primary btn-lg\" type=\"button\" id=\"cancel-consent\" onclick=\"cancelConsent();\"&gt; 取消 &lt;/button&gt; &lt;/div&gt; &lt;div style=\"margin-top: 5px;width: 100%;height: 50px\"&gt; &lt;p style=\"text-align: center;font-size: 14px\"&gt;授权将重定向到&lt;/p&gt; &lt;p style=\"text-align: center;font-size: 14px\"&gt;&lt;b th:text=\"${redirectUri}\"&gt;&lt;/b&gt;&lt;/p&gt; &lt;/div&gt; &lt;/form&gt; &lt;/div&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 访问授权页面启动服务后，我们将发起一个授权请求，http://localhost:8080/oauth2/authorize?response_type=code&amp;client_id=relive-client&amp;scope=message.write%20message.read%20profile&amp;state=some-state&amp;redirect_uri=http://127.0.0.1:8070/login/oauth2/code/messaging-client-authorization-code，在认证成功后，我们可以看到以下我们定义的授权同意页面： 结论与往常一样，本文中使用的源代码可在 GitHub 上获得。","link":"/2022/06/28/custom-oauth2-consent-page/"},{"title":"设计模式-工厂方法模式","text":"工厂方法模式定义工厂方法模式使用的频率非常高，在日常开发中经常会使用，其定义为： 定义一个用于创建对象的接口，让子类决定实例化哪一个类。工厂方法使一个类的实例化延迟到其子类。 通用类图如下： 工厂方法模式中，抽象产品类定义产品的共性；Factory为抽象创建类，也就是抽象工厂。代码如下： 抽象产品类代码： 123456789public abstract class Product { //产品类的公共方法 public void method1(){ //doSomething } public abstract void method2();} 具体产品类可以有多个，都继承与抽象产品类，代码如下： 12345678910111213public class ConcreteProduct1 extends Product{ @Override public void method2() { System.out.println(\"具体产品类1\"); }}public class ConcreteProduct2 extends Product{ @Override public void method2() { System.out.println(\"具体产品类2\"); }} 抽象工厂类负责定义产品对象产生，代码如下： 1234public interface ProductFactory { //创建一个产品类对象，参数可以自行设置 &lt;T extends Product&gt; T createProduct(Class&lt;T&gt; clazz);} 具体如何产生一个产品的对象，由具体的工厂类实现，代码如下： 123456789101112public class ConcreteProductFactory implements ProductFactory { @Override public &lt;T extends Product&gt; T createProduct(Class&lt;T&gt; clazz) { Product product = null; try { product = (Product) Class.forName(clazz.getName()).newInstance(); } catch (Exception e) { //异常处理 } return (T) product; }} 工厂方法模式优点 良好的封装性，代码结构清晰。对于客户端隐藏创建对象的复杂过程，降低模块间的耦合。 扩展性高。在增加产品类的情况下，只要修改具体的工厂类或扩展一个工厂类。 屏蔽产品类。产品类的实现如何变化，客户端都不需要关心，他只需要关心产品的接口，因为产品类的实例化由工厂类负责。 工厂方法模式是典型的解耦框架。高层模块只需要知道产品的抽象类，其他实现类都不关心，符合迪米特法则。只依赖产品类的抽象，符合依赖倒置原则。使用产品子类替换产品父类，也符合里氏替换原则。 使用场景工厂方法模式是new一个对象的替代品，在需要灵活的，可扩展的框架时，可以考虑采用工厂方法模式。例如使用JDBC数据库连接，数据库从MySQL切换到Oracle，需要改动的地方就是切换下驱动名称（前提SQL是标准语句）。 工厂方法模式的扩展简单工厂模式在工厂方法模式中，我们考虑一个模块只需要一个工厂类，根据这一需求，稍微改动下，将抽象工厂类去掉，类图如下： 我们去掉Factory抽象类，并把创建createProduct方法设置为静态类型，变更代码如下： 123456789101112public class ConcreteProductFactory { @Override public &lt;T extends Product&gt; T createProduct(Class&lt;T&gt; clazz) { Product product = null; try { product = (Product) Class.forName(clazz.getName()).newInstance(); } catch (Exception e) { //异常处理 } return (T) product; }} 简单工厂模式是工厂模式的弱化，在实际开发中，采用此模式还是比较多的，但是其缺点是工厂类的扩展比较困难，不符合开闭原则。 多工厂类当我们做一个复杂项目时，如果遇到一个对象初始化很耗费精力的情况，那么将所有产品类放到一个工厂方法中会使结构不清晰，例如产品类有5个具体实现，那么此时工厂方法可能会变得巨大无比。 考虑需要结构清晰，我们就为每个产品类创造一个工厂类，由客户端决定与哪个工厂方法关联。 多工厂模式的抽象工厂类代码如下： 1234public interface MultiProductFactory { Product createProduct();} 此时抽象方法不需要传递参数，因为每个具体工厂职责已经很明确了，只需要负责创建自己负责的产品类对象。 产品类1工厂类实现： 123456public class Concrete1MultiProductFactory implements MultiProductFactory{ @Override public Product createProduct() { return new ConcreteProduct1(); }} 产品类2工程类实现： 123456public class Concrete2MultiProductFactory implements MultiProductFactory { @Override public Product createProduct() { return new ConcreteProduct2(); }} 此种模式就是创建类职责清晰，但是给扩展性和维护性带来了一定的影响。如果扩展一个产品类，就需要建立相应的工厂类，这样增加了扩展的难度。因为工厂类和产品类数量相同，维护时需要考虑两个对象之间的关系。当然在采用多工厂时，可以增加一个协调类，避免客户端与各个子工厂交流，协调类的作用封装子工厂类，对外提供统一的访问接口。 延迟初始化一个对象消费完毕后，并不立刻释放，工厂类保持其初始状态，等待再次被调用。延迟初始化是工厂方法模式的一个扩展应用。 工厂类负责对象的创建工作，并通过HashMap产生一个缓存，对需要再次被调用的对象保留，参考代码如下： 123456789101112131415161718public class LazyProductFactory { private static final Map&lt;String, Product&gt; map = new HashMap&lt;&gt;(); public static synchronized Product createProduct(String type) { Product product; if (map.containsKey(type)) { product = map.get(type); } else { if (\"product1\".equals(type)) { product = new ConcreteProduct1(); } else { product = new ConcreteProduct2(); } map.put(type, product); } return product; }} 实现比较简单，通过定义一个Map容器，缓存所有产生的对象，再次调用时如果Map中已经包含则直接返回，否则根据需要产生一个对象并存Map中。 结论与往常一样，本文中使用的源代码可在 GitHub 上获得。","link":"/2022/05/15/factory-pattern/"},{"title":"使用Java连接SSH","text":"简介SSH 为建立在应用层基础上的安全协议。SSH 是较可靠，专为远程登录会话和其他网络服务提供安全性的协议。 JschJSch 是 SSH2的纯 Java 实现。JSch 允许你连接到一个 sshd 服务器并使用端口转发、X11 转发、文件传输等，你可以将它的功能集成到你自己的 Java 程序中。 首先，让我们将JSch Maven 依赖添加到我们的pom.xml文件中： 12345&lt;dependency&gt; &lt;groupId&gt;com.jcraft&lt;/groupId&gt; &lt;artifactId&gt;jsch&lt;/artifactId&gt; &lt;version&gt;0.1.55&lt;/version&gt;&lt;/dependency&gt; 执行要使用Jsch连接ssh，需要提供用户名，密码，主机，端口，以下是简单代码实例： 123456789101112131415161718192021222324252627282930313233343536373839public static void execCommand(String username, String password, String host, Integer port, String command) throws JSchException, InterruptedException { Session session = null; ChannelExec channel = null; try { session = new JSch().getSession(username, host, port); session.setPassword(password); session.setConfig(\"StrictHostKeyChecking\", \"no\"); session.connect(); channel = (ChannelExec) session.openChannel(\"exec\"); channel.setCommand(command); ByteArrayOutputStream responseStream = new ByteArrayOutputStream(); channel.setOutputStream(responseStream); ByteArrayOutputStream errorResponseStream = new ByteArrayOutputStream(); channel.setErrStream(errorResponseStream); channel.connect(); while (channel.isConnected()) { Thread.sleep(100); } String responseString = new String(responseStream.toByteArray(), StandardCharsets.UTF_8); if (!responseString.isEmpty()) { log.info(responseString); } String errorResponseString = new String(errorResponseStream.toByteArray(), StandardCharsets.UTF_8); if (!errorResponseString.isEmpty()) { log.warn(errorResponseString); } } finally { if (session != null) { session.disconnect(); } if (channel != null) { channel.disconnect(); } } } 上述代码中我们首先建立SSH会话，通过会话建立执行通道，执行我们提供的shell命令，并将响应信息和错误响应信息输出到控制台。 如何使用 JSch 提供的不同配置参数： StrictHostKeyChecking - 它指示应用程序是否将检查是否可以在已知主机中找到主机公钥。此外，可用的参数值是ask、yes和no，其中ask是默认值。如果我们将此属性设置为yes，JSch 将永远不会自动将主机密钥添加到known_hosts文件，并且它将拒绝连接到主机密钥已更改的主机。这会强制用户手动添加所有新主机。如果我们将其设置为 no，JSch 会自动将新的主机密钥添加到已知主机列表中 compression.s2c – 指定是否对从服务器到客户端应用程序的数据流使用压缩。可用值为zlib和none，其中第二个是默认值 compression.c2s – 指定是否对客户端-服务器方向的数据流使用压缩。可用值为zlib和none，其中第二个是默认值 Apache MINA SSHDApache SSHD 是一个 100% 纯 Java 库，支持客户端和服务器端的 SSH 协议。该库基于Apache MINA，这是一个可扩展的高性能异步 IO 库。 首先，让我们将sshd Maven 依赖添加到我们的pom.xml文件中： 12345&lt;dependency&gt; &lt;groupId&gt;org.apache.sshd&lt;/groupId&gt; &lt;artifactId&gt;sshd-core&lt;/artifactId&gt; &lt;version&gt;2.8.0&lt;/version&gt;&lt;/dependency&gt; 执行同样，建立ssh连接需要提供用户名，密码，主机地址，端口，除此之外，sshd可以设置连接超时时间，以下提供简单的代码示例： 123456789101112131415161718192021222324252627282930313233343536public static void execCommand(String username, String password, String host, Integer port, Integer defaultTimeoutSeconds, String command) throws IOException { SshClient client = SshClient.setUpDefaultClient(); client.start(); try (ClientSession session = client.connect(username, host, port) .verify(defaultTimeoutSeconds, TimeUnit.SECONDS) .getSession()) { session.addPasswordIdentity(password); session.auth().verify(defaultTimeoutSeconds, TimeUnit.SECONDS); try (ByteArrayOutputStream responseStream = new ByteArrayOutputStream(); ByteArrayOutputStream errorResponseStream = new ByteArrayOutputStream(); ClientChannel channel = session.createChannel(Channel.CHANNEL_SHELL)) { channel.setOut(responseStream); channel.setErr(errorResponseStream); try { channel.open().verify(defaultTimeoutSeconds, TimeUnit.SECONDS); try (OutputStream pipedIn = channel.getInvertedIn()) { pipedIn.write(command.getBytes()); pipedIn.flush(); } channel.waitFor(EnumSet.of(ClientChannelEvent.CLOSED), TimeUnit.SECONDS.toMillis(defaultTimeoutSeconds)); String errorString = new String(errorResponseStream.toByteArray()); if (!errorString.isEmpty()) { log.warn(errorString); } String responseString = new String(responseStream.toByteArray()); if (!responseString.isEmpty()) { log.info(responseString); } } finally { channel.close(false); } } } finally { client.stop(); } } 结论与往常一样，本文中使用的源代码可在 GitHub 上获得。","link":"/2022/05/15/java-ssh/"},{"title":"Mybatis-plus遇到MySQL关键字如何解决","text":"Mybatis-plus遇到MySQL关键字如何解决在我们开发中经常会遇到在实体类中某个字段是MySQL的关键字，例如： 1234567@TableNamepublic class User { private Long id; private String username; private String describe;} 在我们使用Mybatis查询是会遇到报错，提示信息： 11064 - You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near 'describe from user' at line 1, Time: 0.009000s 这是因为Mybatis在执行sql时并没有将查询字段并没有通过间隔号，所以MySQL会把describe当作关键字。 首先遇到这种情况，一我们可以更改字段名避免使用MySQL的关键字；二如果字段名不方便修改，那么我们可以使用@TableField显示的将字段使用间隔号。修改后实体类如下： 1234567@TableNamepublic class User { private Long id; private String username; @TableName(\"`describe`\") private String describe;}","link":"/2022/05/18/mybatis-mysql-keyword/"},{"title":"Java Weekly 第1期","text":"精选文章 &gt;&gt;从 Postman REST 客户端发送 CSRF 令牌 [baeldung.com] &gt;&gt;使用 Spring Boot 客户端配置为 Kafka 实现 2 路 SSL 和 ACL 身份验证 [medium.com] 2022 Java 程序员路线图 [medium.com] 技术&amp;思考 &gt;&gt;当我开始担任软件工程师时，我想知道的 10 件事 [medium.com]","link":"/2022/06/12/java-weekly-1/"},{"title":"Spring Security OAuth2客户端凭据授权","text":"Spring Security OAuth2客户端凭据授权概述在没有明确的资源拥有者，或对于客户端来说资源拥有者不可区分，该怎么办？这是一种相当常见的场景。比如后端系统之间需要直接通信时，将使用客户端凭据授权。 OAuth2.0文档描述客户端凭据授权： 客户端使用客户端凭据授予类型来获取用户上下文之外的访问令牌。这通常被客户端用来访问关于他们自己的资源，而不是访问用户的资源。 在本文中，您将了解使用Spring Security构建OAuth2客户端凭据授权，在没有经过身份验证的用户的情况下允许服务安全的相互操作。 OAuth2客户端凭据授权相比于授权码授权更直接，它通常用于CRON任务和其他类型的后端数据处理等操作。 客户端凭据授予流程当应用程序请求访问令牌以访问其自己的资源时，将使用客户端凭据授权，而不是代表用户。 请求参数grant_type（必需）该grant_type参数必须设置为client_credentials。 scope（可选的）您的服务可以支持客户端凭据授予的不同范围。 客户端身份验证（必需）客户端需要对此请求进行身份验证。通常，该服务将允许附加请求参数client_id和client_secret，或接受 HTTP Basic auth 标头中的客户端 ID 和机密。 OAuth2授权服务器这里我们使用Spring Authorization Server构建OAuth2授权服务器，具体详细细节我这里就不重复赘述，可以参考此文JWT与Spring Security OAuth2结合使用中授权服务器搭建，这里仅说明与之前授权码授予流程授权服务配置的不同之处。 配置在我们使用RegisteredClient构建器类型创建一个客户端，将配置此客户端支持客户端凭据授权，并简单的将它存储在内存中。 123456789101112131415161718192021222324252627@Beanpublic RegisteredClientRepository registeredClientRepository() { RegisteredClient registeredClient = RegisteredClient.withId(UUID.randomUUID().toString()) .clientId(\"relive-client\") .clientSecret(\"{noop}relive-client\") .clientAuthenticationMethods(s -&gt; { s.add(ClientAuthenticationMethod.CLIENT_SECRET_POST); s.add(ClientAuthenticationMethod.CLIENT_SECRET_BASIC); }) .authorizationGrantType(AuthorizationGrantType.CLIENT_CREDENTIALS) .redirectUri(\"http://127.0.0.1:8070/login/oauth2/code/messaging-client-model\") .scope(\"message.read\") .clientSettings(ClientSettings.builder() .requireAuthorizationConsent(true) .requireProofKey(false) .build()) .tokenSettings(TokenSettings.builder() .accessTokenFormat(OAuth2TokenFormat.SELF_CONTAINED) .idTokenSignatureAlgorithm(SignatureAlgorithm.RS256) .accessTokenTimeToLive(Duration.ofSeconds(30 * 60)) .refreshTokenTimeToLive(Duration.ofSeconds(60 * 60)) .reuseRefreshTokens(true) .build()) .build(); return new InMemoryRegisteredClientRepository(registeredClient);} 上述我们配置了一个OAuth2客户端，并将authorizationGrantType指定为client_credentials： clientId: relive-client clientSecret: relive-client redirectUri: http://127.0.0.1:8070/login/oauth2/code/messaging-client-model scope: message.read 使用Spring Security构建OAuth2资源服务器OAuth2资源服务器配置与此文JWT与Spring Security OAuth2结合使用中资源服务搭建一致，您可以参考此文中OAuth2资源服务介绍，或可以在文末中获取本文源码地址进行查看。 配置OAuth2资源服务器提供了一个/resource/article受保护端点，并使用Spring Security保护此服务。 123456789101112@BeanSecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception { http.requestMatchers() .antMatchers(\"/resource/article\") .and() .authorizeRequests() .mvcMatchers(\"/resource/article\") .access(\"hasAuthority('SCOPE_message.read')\") .and() .oauth2ResourceServer(OAuth2ResourceServerConfigurer::jwt); return http.build();} 请注意，OAuth2资源服务/resource/article端点要求拥有“message.read”权限才可以访问，Spring 自动在所需范围名称前添加“SCOPE_”，这样实际所需的范围是“message.read”而不是“SCOPE_message.read”。 使用Spring Security构建OAuth2客户端在本节中，您将使用当前推荐的WebClient，WebClient 是 Spring 的 WebFlux 包的一部分。这是 Spring 的反应式、非阻塞 API，您可以在Spring文档中了解更多信息。 在此客户端中，在@Scheduled此注解定义的CRON任务下，您将使用WebClient来发出请求。 maven依赖12345678910111213141516171819202122232425&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;version&gt;2.6.7&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-security&lt;/artifactId&gt; &lt;version&gt;2.6.7&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-oauth2-client&lt;/artifactId&gt; &lt;version&gt;2.6.7&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webflux&lt;/artifactId&gt; &lt;version&gt;5.3.9&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;io.projectreactor.netty&lt;/groupId&gt; &lt;artifactId&gt;reactor-netty&lt;/artifactId&gt; &lt;version&gt;1.0.9&lt;/version&gt;&lt;/dependency&gt; 配置授权我们将在application.yml中配置OAuth2授权信息，并指定OAuth2客户端服务端口号： 12345678910111213141516171819server: port: 8070spring: security: oauth2: client: registration: messaging-client-model: provider: client-provider client-id: relive-client client-secret: relive-client authorization-grant-type: client_credentials client-authentication-method: client_secret_post scope: message.read client-name: messaging-client-model provider: client-provider: token-uri: http://127.0.0.1:8080/oauth2/token 接下来我们将创建一个SecurityConfig类用来配置Spring Security OAuth2客户端所需Bean： 12345678910111213141516171819202122232425262728293031@BeanSecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception { http .authorizeRequests(authorizeRequests -&gt; authorizeRequests.anyRequest().permitAll() ) .oauth2Client(withDefaults()); return http.build();}@BeanWebClient webClient(OAuth2AuthorizedClientManager authorizedClientManager) { ServletOAuth2AuthorizedClientExchangeFilterFunction oauth2Client = new ServletOAuth2AuthorizedClientExchangeFilterFunction(authorizedClientManager); return WebClient.builder() .filter(oauth2Client) .build();}@BeanOAuth2AuthorizedClientManager authorizedClientManager(ClientRegistrationRepository clientRegistrationRepository, OAuth2AuthorizedClientService authorizedClientService) { OAuth2AuthorizedClientProvider authorizedClientProvider = OAuth2AuthorizedClientProviderBuilder .builder() .clientCredentials() .build(); AuthorizedClientServiceOAuth2AuthorizedClientManager authorizedClientManager = new AuthorizedClientServiceOAuth2AuthorizedClientManager(clientRegistrationRepository, authorizedClientService); authorizedClientManager.setAuthorizedClientProvider(authorizedClientProvider); return authorizedClientManager;} 我们创建一个WebClient实例用于向资源服务器执行HTTP请求，并给WebClient添加了一个OAuth2授权过滤器。AuthorizedClientServiceOAuth2AuthorizedClientManager这是协调OAuth2客户端凭据授予请求的高级控制器类，这里我将指出AuthorizedClientServiceOAuth2AuthorizedClientManager是一个专门设计用于在 HttpServletRequest 的上下文之外使用的类。 来自Spring 文档： DefaultOAuth2AuthorizedClientManager 旨在用于 HttpServletRequest 的上下文中。在 HttpServletRequest 上下文之外操作时，请改用 AuthorizedClientServiceOAuth2AuthorizedClientManager。 接下来我们将创建使用@Scheduled注解定义的任务，并注入WebClient调用资源服务请求： 12345678910111213141516171819@Servicepublic class ArticleJob { @Autowired private WebClient webClient; @Scheduled(cron = \"0/2 * * * * ? \") public void exchange() { List list = this.webClient .get() .uri(\"http://127.0.0.1:8090/resource/article\") .attributes(clientRegistrationId(\"messaging-client-model\")) .retrieve() .bodyToMono(List.class) .block(); log.info(\"调用资源服务器执行结果：\" + list); }} 这个类中exchange()方法使用@Scheduled注解每2秒触发一次请求，在我们启动所有服务后，你应该看到这样的输出： 12342022-07-09 19:55:22.281 INFO 20305 --- [ scheduling-1] com.relive.ArticleJob : 调用资源服务器执行结果：[article1, article2, article3]2022-07-09 19:55:24.023 INFO 20305 --- [ scheduling-1] com.relive.ArticleJob : 调用资源服务器执行结果：[article1, article2, article3]2022-07-09 19:55:26.015 INFO 20305 --- [ scheduling-1] com.relive.ArticleJob : 调用资源服务器执行结果：[article1, article2, article3]2022-07-09 19:55:28.009 INFO 20305 --- [ scheduling-1] com.relive.ArticleJob : 调用资源服务器执行结果：[article1, article2, article3] 结论与往常一样，本文中使用的源代码可在 GitHub 上获得。","link":"/2022/07/09/oauth2-client-model/"},{"title":"Spring Security OAuth2 带有用于代码交换的证明密钥 (PKCE) 的授权码流","text":"Spring Security OAuth2 带有用于代码交换的证明密钥 (PKCE) 的授权码流 概述OAuth2依据是否能持有客户端密钥，将客户端分为两种类型：公共客户端和保密客户端。 保密客户端在服务器上运行，在前面介绍OAuth2文章中Spring Boot创建的应用程序是保密客户端类型的示例。首先它们在服务器上运行，并且通常位于具有其他保护措施防火墙或网关的后面。 公共客户端的代码一般会以某种形式暴露给最终用户，要么是在浏览器中下载执行，要么是直接在用户的设备上运行。例如原生应用是直接在最终用户的设备（计算机或者移动设备）上运行的应用。这类应用在使用OAuth2协议时，我们无法保证为此应用颁发的客户端密钥能安全的存储，因为这些应用程序在运行之前会完全下载到设备上，反编译应用程序将完全显示客户端密钥。 同样存在此安全问题还有单页应用（SPA），浏览器本身是一个不安全的环境，一旦你加载JavaScript应用程序，浏览器将会下载整个源代码以便运行它，整个源代码，包括其中的任何 客户端密钥，都将可见。如果你构建一个拥有100000名用户的应用程序，那么很可能这些用户中的一部分将感染恶意软件或病毒，并泄漏客户端密钥。 你可能会想，“如果我通过将客户端密钥拆分为几个部分进行混淆呢？”这不可否认会为你争取点时间，但真正有决心的人仍可能会弄清楚。 为了规避这种安全风险，最好使用代码交换证明密钥(PKCE)。 Proof Key for Code ExchangePKCE 有自己独立的规范。它使应用程序能够在公共客户端中使用授权码流程。 用户在客户端请求资源。 客户端创建并记录名为 code_verifier 的秘密信息，然后客户端根据 code_verifier 计算出 code_challenge，它的值可以是 code_verifier，也可以是 code_verifier 的 SHA-256 散列，但是应该优先考虑使用密码散列，因为它能防止验证器本身遭到截获。 客户端将 code_challenge 以及可选的 code_challenge_method(一个关键字，表 示原文或者 SHA-256 散列)与常规的授权请求参数一起发送给授权服务器。 授权服务器将用户重定向到登录页面。 用户使进行身份验证，并且可能会看到一个同意页面，其中列出了 授权服务器将授予客户端的权限。 授权服务器将 code_challenge 和 code_challenge_method(如果有 的话)记录下来。授权服务器会将这些信息与颁发的授权码关联起来，并携带code重定向回客户端。 客户端接收到授权码之后，携带之前生成的 code_verifier 执行令牌请求。 授权服务器根据code_verifier计算出 code_challenge，并检查是否与最初提交的code_challenge一致。 授权服务器向客户端发送令牌。 客户端向受保护资源发送令牌。 受保护资源向客户端返回资源。 使用Spring Authorization Server搭建授权服务器本节我们将使用Spring Authorization Server搭建一个授权服务器，并注册一个客户端使之支持PKCE。 maven1234567891011121314151617&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-security&lt;/artifactId&gt; &lt;version&gt;2.6.7&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.security&lt;/groupId&gt; &lt;artifactId&gt;spring-security-oauth2-authorization-server&lt;/artifactId&gt; &lt;version&gt;0.3.1&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;version&gt;2.6.7&lt;/version&gt;&lt;/dependency&gt; 配置首先很简单，我们将创建application.yml文件，并指定授权服务器端口为8080： 12server: port: 8080 之后我们将创建一个OAuth2ServerConfig配置类，并在此类中我们将创建OAuth2授权服务所需特定Bean： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081@Bean@Order(Ordered.HIGHEST_PRECEDENCE)public SecurityFilterChain authorizationServerSecurityFilterChain(HttpSecurity http) throws Exception { OAuth2AuthorizationServerConfiguration.applyDefaultSecurity(http); return http.exceptionHandling(exceptions -&gt; exceptions. authenticationEntryPoint(new LoginUrlAuthenticationEntryPoint(\"/login\"))).build();}@Beanpublic RegisteredClientRepository registeredClientRepository() { RegisteredClient registeredClient = RegisteredClient.withId(UUID.randomUUID().toString()) .clientId(\"relive-client\") .clientAuthenticationMethods(s -&gt; { s.add(ClientAuthenticationMethod.NONE);//客户端认证模式为none }) .authorizationGrantType(AuthorizationGrantType.AUTHORIZATION_CODE) .redirectUri(\"http://127.0.0.1:8070/login/oauth2/code/messaging-client-pkce\") .scope(\"message.read\") .clientSettings(ClientSettings.builder() .requireAuthorizationConsent(true) .requireProofKey(true) //仅支持PKCE .build()) .tokenSettings(TokenSettings.builder() .accessTokenFormat(OAuth2TokenFormat.SELF_CONTAINED) // 生成JWT令牌 .idTokenSignatureAlgorithm(SignatureAlgorithm.RS256) .accessTokenTimeToLive(Duration.ofSeconds(30 * 60)) .refreshTokenTimeToLive(Duration.ofSeconds(60 * 60)) .reuseRefreshTokens(true) .build()) .build(); return new InMemoryRegisteredClientRepository(registeredClient);}@Beanpublic ProviderSettings providerSettings() { return ProviderSettings.builder() .issuer(\"http://127.0.0.1:8080\") .build();}@Beanpublic JWKSource&lt;SecurityContext&gt; jwkSource() { RSAKey rsaKey = Jwks.generateRsa(); JWKSet jwkSet = new JWKSet(rsaKey); return (jwkSelector, securityContext) -&gt; jwkSelector.select(jwkSet);}static class Jwks { private Jwks() { } public static RSAKey generateRsa() { KeyPair keyPair = KeyGeneratorUtils.generateRsaKey(); RSAPublicKey publicKey = (RSAPublicKey) keyPair.getPublic(); RSAPrivateKey privateKey = (RSAPrivateKey) keyPair.getPrivate(); return new RSAKey.Builder(publicKey) .privateKey(privateKey) .keyID(UUID.randomUUID().toString()) .build(); }}static class KeyGeneratorUtils { private KeyGeneratorUtils() { } static KeyPair generateRsaKey() { KeyPair keyPair; try { KeyPairGenerator keyPairGenerator = KeyPairGenerator.getInstance(\"RSA\"); keyPairGenerator.initialize(2048); keyPair = keyPairGenerator.generateKeyPair(); } catch (Exception ex) { throw new IllegalStateException(ex); } return keyPair; }} 请注意在创建RegisteredClient注册客户端类中，1.我们没有定义client_secret;2.客户端认证模式指定为none；3.requireProofKey()设置为true，此客户端仅支持PKCE。 其余配置我这里就不一一说明，可以参考之前文章。 接下来，我们创建一个Spring Security的配置类，指定Form表单认证和设置用户名密码： 1234567891011121314151617181920212223242526272829@Configurationpublic class SecurityConfig { @Bean SecurityFilterChain defaultSecurityFilterChain(HttpSecurity http) throws Exception { http .authorizeRequests(authorizeRequests -&gt; authorizeRequests.anyRequest().authenticated() ) .formLogin(withDefaults()); return http.build(); } @Bean UserDetailsService users() { UserDetails user = User.withDefaultPasswordEncoder() .username(\"admin\") .password(\"password\") .roles(\"USER\") .build(); return new InMemoryUserDetailsManager(user); } @Bean PasswordEncoder passwordEncoder() { return PasswordEncoderFactories.createDelegatingPasswordEncoder(); }} 至此我们就已经配置好了一个简单的授权服务器。 OAuth2客户端本节中我们使用Spring Security创建一个客户端，此客户端通过PKCE授权码流向授权服务器请求授权，并将获取的access_token发送到资源服务。 maven1234567891011121314151617181920212223242526&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;version&gt;2.6.7&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-security&lt;/artifactId&gt; &lt;version&gt;2.6.7&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-oauth2-client&lt;/artifactId&gt; &lt;version&gt;2.6.7&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webflux&lt;/artifactId&gt; &lt;version&gt;5.3.9&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;io.projectreactor.netty&lt;/groupId&gt; &lt;artifactId&gt;reactor-netty&lt;/artifactId&gt; &lt;version&gt;1.0.9&lt;/version&gt;&lt;/dependency&gt; 配置首先我们将在application.yml中配置客户端信息，并指定服务端口号为8070： 1234567891011121314151617181920212223242526server: port: 8070 servlet: session: cookie: name: CLIENT-SESSIONspring: security: oauth2: client: registration: messaging-client-pkce: provider: client-provider client-id: relive-client client-secret: relive-client authorization-grant-type: authorization_code client-authentication-method: none redirect-uri: \"http://127.0.0.1:8070/login/oauth2/code/{registrationId}\" scope: message.read client-name: messaging-client-pkce provider: client-provider: authorization-uri: http://127.0.0.1:8080/oauth2/authorize token-uri: http://127.0.0.1:8080/oauth2/token 接下来，我们创建Spring Security配置类，启用OAuth2客户端。 1234567891011121314151617181920212223242526272829303132333435363738@Configurationpublic class SecurityConfig { @Bean SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception { http .authorizeRequests(authorizeRequests -&gt; //便于测试，将权限开放 authorizeRequests.anyRequest().permitAll() ) .oauth2Client(withDefaults()); return http.build(); } @Bean WebClient webClient(OAuth2AuthorizedClientManager authorizedClientManager) { ServletOAuth2AuthorizedClientExchangeFilterFunction oauth2Client = new ServletOAuth2AuthorizedClientExchangeFilterFunction(authorizedClientManager); return WebClient.builder() .filter(oauth2Client) .build(); } @Bean OAuth2AuthorizedClientManager authorizedClientManager(ClientRegistrationRepository clientRegistrationRepository, OAuth2AuthorizedClientRepository authorizedClientRepository) { OAuth2AuthorizedClientProvider authorizedClientProvider = OAuth2AuthorizedClientProviderBuilder .builder() .authorizationCode() .refreshToken() .build(); DefaultOAuth2AuthorizedClientManager authorizedClientManager = new DefaultOAuth2AuthorizedClientManager(clientRegistrationRepository, authorizedClientRepository); authorizedClientManager.setAuthorizedClientProvider(authorizedClientProvider); return authorizedClientManager; }} 上述配置类中我们通过oauth2Client(withDefaults())启用OAuth2客户端。并创建一个WebClient实例用于向资源服务器执行HTTP请求。OAuth2AuthorizedClientManager这是协调OAuth2授权码请求的高级控制器类，不过授权码流程并不是由它控制，可以查看它所管理的Provider实现类AuthorizationCodeOAuth2AuthorizedClientProvider中并没有涉及相关授权码流程代码逻辑，对于Spring Security授权码模式涉及核心接口流程我会放在之后的文章统一介绍。回到OAuth2AuthorizedClientManager类中，我们可以看到同时还指定了refreshToken(),它实现了刷新token逻辑，将在请求资源服务过程中access_token过期后将刷新token，前提是refresh_token没有过期，否则你将重新执行OAuth2授权码流程。 接下来，我们创建一个Controller类，使用WebClient请求资源服务： 1234567891011121314151617@RestControllerpublic class PkceClientController { @Autowired private WebClient webClient; @GetMapping(value = \"/client/test\") public List getArticles(@RegisteredOAuth2AuthorizedClient(\"messaging-client-pkce\") OAuth2AuthorizedClient authorizedClient) { return this.webClient .get() .uri(\"http://127.0.0.1:8090/resource/article\") .attributes(oauth2AuthorizedClient(authorizedClient)) .retrieve() .bodyToMono(List.class) .block(); }} 资源服务器本节中，我们将使用Spring Security搭建一个资源服务器。 maven123456789101112131415&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;version&gt;2.6.7&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-security&lt;/artifactId&gt; &lt;version&gt;2.6.7&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-oauth2-resource-server&lt;/artifactId&gt; &lt;version&gt;2.6.7&lt;/version&gt; &lt;/dependency&gt; 配置通过application.yml配置资源服务器服务端口8070，并指定授权服务器jwk uri，用于获取公钥信息验证token令牌： 123456789server: port: 8090spring: security: oauth2: resourceserver: jwt: jwk-set-uri: http://127.0.0.1:8080/oauth2/jwks 接下来配置Spring Security配置类，指定受保护端点访问权限： 1234567891011121314151617@Configurationpublic class SecurityConfig { @Bean public SecurityFilterChain defaultSecurityFilter(HttpSecurity http) throws Exception { http.requestMatchers() .antMatchers(\"/resource/article\") .and() .authorizeHttpRequests((authorize) -&gt; authorize .antMatchers(\"/resource/article\") .hasAuthority(\"SCOPE_message.read\") .mvcMatchers() ) .oauth2ResourceServer(OAuth2ResourceServerConfigurer::jwt); return http.build(); }} 上述配置类中指定/resource/article必须拥有message.read权限才能访问，并配置资源服务使用JWT身份验证。 之后我们将创建Controller类，作为受保护端点： 12345678@RestControllerpublic class ArticleRestController { @GetMapping(\"/resource/article\") public List&lt;String&gt; article() { return Arrays.asList(\"article1\", \"article2\", \"article3\"); }} 访问资源列表启动所有服务后，在浏览器中输入 http://127.0.0.1:8070/client/test ，通过授权服务器认证后，您将在页面中看到以下输出信息： 1[\"article1\",\"article2\",\"article3\"] 结论在Spring Security目前版本中保密客户端的 PKCE 已经成为默认行为。在保密客户端授权码模式中同样可以使用PKCE。 与往常一样，本文中使用的源代码可在 GitHub 上获得。","link":"/2022/07/17/oauth2-pkce/"},{"title":"Spring Security OAuth2登录","text":"Spring Security OAuth2登录概述OAuth 2.0 不是身份认证协议。 什么是身份认证？身份认证是解决“你是谁？”的问题。身份认证会告诉应用当前用户是谁以及是否在使用此应用。实际中可能还会告诉你用户的名称，邮箱，手机号等。 如果对 OAuth 2.0 进行扩展，使得授权服务器和受保护资源发出的信息能够传达与用户以及他们的身份认证上下文有关的信息，我们就可以为客户端提供用于用户安全登录的所有信息。这种基于OAuth 2.0授权协议而构建的身份认证方式主要优点： 用户在授权服务器上执行身份认证， 最终用户的原始凭据不会通过 OAuth 2.0 协议传送到客户端应用。 允许用户在运行时执行同意决策。 用户还可以将其他受保护 API 与他的身份信息的访问权限一起授权出去。通过一个调用，应用就可以知道用户是否已登录，如何称呼用户，用户的手机号，邮箱等。 本文我们将通过OAuth 2.0 授权码模式安全的传递授权服务用户信息，并登录到客户端应用。 本文您将学到： 搭建基本的授权服务和客户端服务 自定义授权服务器访问令牌，添加角色信息 自定义授权服务器用户信息端点 客户端服务使用GrantedAuthoritiesMapper做权限映射 客户端服务自定义OAuth2UserService实现解析多层Json数据 OAuth2授权服务器本节我们将使用Spring Authorization Server搭建一个授权服务器。除此之外我们还将会自定义access_token和自定义用户信息端点。 maven1234567891011121314151617&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-security&lt;/artifactId&gt; &lt;version&gt;2.6.7&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.security&lt;/groupId&gt; &lt;artifactId&gt;spring-security-oauth2-authorization-server&lt;/artifactId&gt; &lt;version&gt;0.3.1&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;version&gt;2.6.7&lt;/version&gt;&lt;/dependency&gt; 配置首先通过application.yml配置服务端口8080: 12server: port: 8080 接下来我们将创建OAuth2ServerConfig配置类，定义OAuth2 授权服务所需特定Bean。首先我们注册一个OAuth2客户端: 123456789101112131415161718192021222324252627@Beanpublic RegisteredClientRepository registeredClientRepository() { RegisteredClient registeredClient = RegisteredClient.withId(UUID.randomUUID().toString()) .clientId(\"relive-client\") .clientSecret(\"{noop}relive-client\") .clientAuthenticationMethods(s -&gt; { s.add(ClientAuthenticationMethod.CLIENT_SECRET_POST); s.add(ClientAuthenticationMethod.CLIENT_SECRET_BASIC); }) .authorizationGrantType(AuthorizationGrantType.AUTHORIZATION_CODE) .authorizationGrantType(AuthorizationGrantType.REFRESH_TOKEN) .redirectUri(\"http://127.0.0.1:8070/login/oauth2/code/messaging-client-authorization-code\") .scope(OidcScopes.PROFILE) .clientSettings(ClientSettings.builder() .requireAuthorizationConsent(true) .requireProofKey(false) .build()) .tokenSettings(TokenSettings.builder() .accessTokenFormat(OAuth2TokenFormat.SELF_CONTAINED) .idTokenSignatureAlgorithm(SignatureAlgorithm.RS256)/ .accessTokenTimeToLive(Duration.ofSeconds(30 * 60)) .refreshTokenTimeToLive(Duration.ofSeconds(60 * 60)) .reuseRefreshTokens(true) .build()) .build(); return new InMemoryRegisteredClientRepository(registeredClient);} 以上将OAuth2客户端存储在内存中，如果您需要使用数据库持久化，请参考文章将JWT与Spring Security OAuth2结合使用。指定OAuth2客户端信息如下： clientId: relive-client clientSecret: relive-client redirectUri: http://127.0.0.1:8070/login/oauth2/code/messaging-client-authorization-code scope: profile 接下来让我们配置OAuth2授权服务其他默认配置，并对未认证的授权请求重定向到登录页面： 12345678910@Bean@Order(Ordered.HIGHEST_PRECEDENCE)public SecurityFilterChain authorizationServerSecurityFilterChain(HttpSecurity http) throws Exception { OAuth2AuthorizationServerConfiguration.applyDefaultSecurity(http); return http .exceptionHandling(exceptions -&gt; exceptions. authenticationEntryPoint(new LoginUrlAuthenticationEntryPoint(\"/login\"))) .build();} 授权服务器token令牌格式使用JWT RFC 7519，所以我们需要用于令牌的签名密钥，让我们生成一个RSA密钥： 12345678910111213141516171819202122232425262728293031323334353637383940@Beanpublic JWKSource&lt;SecurityContext&gt; jwkSource() { RSAKey rsaKey = Jwks.generateRsa(); JWKSet jwkSet = new JWKSet(rsaKey); return (jwkSelector, securityContext) -&gt; jwkSelector.select(jwkSet);}static class Jwks { private Jwks() { } public static RSAKey generateRsa() { KeyPair keyPair = KeyGeneratorUtils.generateRsaKey(); RSAPublicKey publicKey = (RSAPublicKey) keyPair.getPublic(); RSAPrivateKey privateKey = (RSAPrivateKey) keyPair.getPrivate(); return new RSAKey.Builder(publicKey) .privateKey(privateKey) .keyID(UUID.randomUUID().toString()) .build(); }}static class KeyGeneratorUtils { private KeyGeneratorUtils() { } static KeyPair generateRsaKey() { KeyPair keyPair; try { KeyPairGenerator keyPairGenerator = KeyPairGenerator.getInstance(\"RSA\"); keyPairGenerator.initialize(2048); keyPair = keyPairGenerator.generateKeyPair(); } catch (Exception ex) { throw new IllegalStateException(ex); } return keyPair; }} 接下来我们将自定义access_token 访问令牌，并在令牌中添加角色信息： 123456789101112131415@Configuration(proxyBeanMethods = false)public class AccessTokenCustomizerConfig { @Bean public OAuth2TokenCustomizer&lt;JwtEncodingContext&gt; tokenCustomizer() { return (context) -&gt; { if (OAuth2TokenType.ACCESS_TOKEN.equals(context.getTokenType())) { context.getClaims().claims(claim -&gt; { claim.put(\"role\", context.getPrincipal().getAuthorities().stream() .map(GrantedAuthority::getAuthority).collect(Collectors.toSet())); }); } }; }} 可以看到Spring Security为我们提供了OAuth2TokenCustomizer用于扩展令牌信息，我们从OAuth2TokenContext获取到当前用户信息，并从中提取Authorities权限信息添加到JWT的claim。 下面我们将创建Spring Security配置类，配置授权服务基本的认证能力。 1234567891011121314151617181920212223242526272829303132@Configuration(proxyBeanMethods = false)public class DefaultSecurityConfig { @Bean public SecurityFilterChain defaultSecurityFilterChain(HttpSecurity http) throws Exception { http.authorizeRequests() .antMatchers(\"/userInfo\") .access(\"hasAnyAuthority('SCOPE_profile')\") .mvcMatchers(\"/userInfo\") .access(\"hasAuthority('SCOPE_profile')\") .anyRequest().authenticated() .and() .formLogin(Customizer.withDefaults()) .oauth2ResourceServer(OAuth2ResourceServerConfigurer::jwt); return http.build(); } @Bean public JwtDecoder jwtDecoder(JWKSource&lt;SecurityContext&gt; jwkSource) { return OAuth2AuthorizationServerConfiguration.jwtDecoder(jwkSource); } @Bean public UserDetailsService users() { UserDetails user = User.withDefaultPasswordEncoder() .username(\"admin\") .password(\"password\") .roles(\"ADMIN\") .build(); return new InMemoryUserDetailsManager(user); }} 在上述配置类中，我们做了以下几件事。1.启用Form认证方式；2.配置登录用户名密码；3.使用oauth2ResourceServer()配置JWT验证，并声明JwtDecoder；4.保护/userInfo端点需要profile权限进行访问。 此时我们还需要创建Controller类，用于提供给OAuth2客户端服务获取用户信息： 12345678@RestControllerpublic class UserInfoController { @PostMapping(\"/userInfo\") public Map&lt;String, Object&gt; getUserInfo(@AuthenticationPrincipal Jwt jwt) { return Collections.singletonMap(\"data\", jwt.getClaims()); }} 我们将用户信息使用以下JSON格式返回： 123456{ \"data\":{ \"sub\":\"admin\" ... }} OAuth2客户端服务本节将使用Spring Security配置OAuth2客户端登录；并且我们将使用GrantedAuthoritiesMapper映射权限信息；还将通过自定义实现OAuth2UserService替换原有DefaultOAuth2UserService，用于解析多层JSON 用户信息数据。 maven12345678910111213141516171819202122&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;version&gt;2.6.7&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-security&lt;/artifactId&gt; &lt;version&gt;2.6.7&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-oauth2-client&lt;/artifactId&gt; &lt;version&gt;2.6.7&lt;/version&gt; &lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt; &lt;version&gt;2.6.7&lt;/version&gt; &lt;/dependency&gt; 配置首先我们指定客户端服务端口号8070,并配置OAuth2客户端相关信息： 12345678910111213141516171819202122232425262728server: port: 8070 servlet: session: cookie: name: CLIENT-SESSIONspring: security: oauth2: client: registration: messaging-client-authorization-code: provider: client-provider client-id: relive-client client-secret: relive-client authorization-grant-type: authorization_code redirect-uri: \"{baseUrl}/login/oauth2/code/{registrationId}\" scope: profile client-name: messaging-client-authorization-code provider: client-provider: authorization-uri: http://127.0.0.1:8080/oauth2/authorize token-uri: http://127.0.0.1:8080/oauth2/token user-info-uri: http://127.0.0.1:8080/userInfo user-name-attribute: data.sub user-info-authentication-method: form 接下来配置Spring Security相关Bean，首先我们先启用Form表单认证和OAuth2登录能力： 12345678910111213@BeanSecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception { http.authorizeHttpRequests() .anyRequest() .authenticated() .and() .formLogin(from -&gt; { from.defaultSuccessUrl(\"/home\"); }) .oauth2Login(Customizer.withDefaults()) .csrf().disable(); return http.build();} 这里我们指定认证成功后重定向到/home路径下。 下面我们使用GrantedAuthoritiesMapper映射用户权限： 123456789101112131415161718192021@BeanGrantedAuthoritiesMapper userAuthoritiesMapper() { //角色映射关系，授权服务器ADMIN角色对应客户端OPERATION角色 Map&lt;String, String&gt; roleMapping = new HashMap&lt;&gt;(); roleMapping.put(\"ROLE_ADMIN\", \"ROLE_OPERATION\"); return (authorities) -&gt; { Set&lt;GrantedAuthority&gt; mappedAuthorities = new HashSet&lt;&gt;(); authorities.forEach(authority -&gt; { if (OAuth2UserAuthority.class.isInstance(authority)) { OAuth2UserAuthority oauth2UserAuthority = (OAuth2UserAuthority) authority; Map&lt;String, Object&gt; userAttributes = oauth2UserAuthority.getAttributes(); List&lt;String&gt; role = (List) userAttributes.get(\"role\"); role.stream().map(roleMapping::get) .filter(StringUtils::hasText) .map(SimpleGrantedAuthority::new) .forEach(mappedAuthorities::add); } }); return mappedAuthorities; };} 上述将OAuth2授权服务ADMIN角色映射为客户端角色OPERATION。当然你同样可以扩展为数据库操作，那么需要你维护授权服务角色与客户端服务角色映射表，这里将不展开。 GrantedAuthoritiesMapper作为权限映射器在OAuth2登录，CAS登录，SAML和LDAP多方使用。 GrantedAuthoritiesMapper在OAuth2LoginAuthenticationProvider中源码如下： 12345678910111213141516@Overridepublic Authentication authenticate(Authentication authentication) throws AuthenticationException { OAuth2LoginAuthenticationToken loginAuthenticationToken = (OAuth2LoginAuthenticationToken) authentication; //...省略部分源码 /* map authorities */ Collection&lt;? extends GrantedAuthority&gt; mappedAuthorities = this.authoritiesMapper .mapAuthorities(oauth2User.getAuthorities()); /* map authorities */ OAuth2LoginAuthenticationToken authenticationResult = new OAuth2LoginAuthenticationToken( loginAuthenticationToken.getClientRegistration(), loginAuthenticationToken.getAuthorizationExchange(), oauth2User, mappedAuthorities, accessToken, authorizationCodeAuthenticationToken.getRefreshToken()); authenticationResult.setDetails(loginAuthenticationToken.getDetails()); return authenticationResult;} 所以当我们自定义实现GrantedAuthoritiesMapper后，OAuth2 登录成功后将映射后的权限信息存储在认证信息Authentication的子类OAuth2LoginAuthenticationToken中，在后续流程中需要时获取。 接下来将实现OAuth2UserService自定义DefaultJsonOAuth2UserService类。当然Spring Security提供了DefaultOAuth2UserService，那么为什么不使用它呢？原因很简单，首先让我们回顾授权服务器返回用户信息格式： 123456{ \"data\":{ \"sub\":\"admin\" ... }} 不错，用户信息嵌套data字段中，而DefaultOAuth2UserService处理用户信息响应时并没有处理这个格式，以下是DefaultOAuth2UserService源码： 12345678910111213141516171819202122232425262728293031public OAuth2User loadUser(OAuth2UserRequest userRequest) throws OAuth2AuthenticationException { Assert.notNull(userRequest, \"userRequest cannot be null\"); if (!StringUtils.hasText(userRequest.getClientRegistration().getProviderDetails().getUserInfoEndpoint().getUri())) { OAuth2Error oauth2Error = new OAuth2Error(\"missing_user_info_uri\", \"Missing required UserInfo Uri in UserInfoEndpoint for Client Registration: \" + userRequest.getClientRegistration().getRegistrationId(), (String)null); throw new OAuth2AuthenticationException(oauth2Error, oauth2Error.toString()); } else { String userNameAttributeName = userRequest.getClientRegistration().getProviderDetails().getUserInfoEndpoint().getUserNameAttributeName(); if (!StringUtils.hasText(userNameAttributeName)) { OAuth2Error oauth2Error = new OAuth2Error(\"missing_user_name_attribute\", \"Missing required \\\"user name\\\" attribute name in UserInfoEndpoint for Client Registration: \" + userRequest.getClientRegistration().getRegistrationId(), (String)null); throw new OAuth2AuthenticationException(oauth2Error, oauth2Error.toString()); } else { RequestEntity&lt;?&gt; request = (RequestEntity)this.requestEntityConverter.convert(userRequest); /* 获取用户信息 */ ResponseEntity&lt;Map&lt;String, Object&gt;&gt; response = this.getResponse(userRequest, request); //在这里直接获取响应体信息，默认此userAttributes包含相关用户信息，并没有解析多层JSON Map&lt;String, Object&gt; userAttributes = (Map)response.getBody(); /* 获取用户信息 */ Set&lt;GrantedAuthority&gt; authorities = new LinkedHashSet(); authorities.add(new OAuth2UserAuthority(userAttributes)); OAuth2AccessToken token = userRequest.getAccessToken(); Iterator var8 = token.getScopes().iterator(); while(var8.hasNext()) { String authority = (String)var8.next(); authorities.add(new SimpleGrantedAuthority(\"SCOPE_\" + authority)); } return new DefaultOAuth2User(authorities, userAttributes, userNameAttributeName); } } } 而最后创建DefaultOAuth2User时，你可能会收到以下错误信息 1Missing attribute 'sub' in attributes 通过上面源码，Spring Security 所希望返回的用户信息格式： 1234{ \"sub\":\"admin\", ...} 但是实际中，我们开发时通常会统一返回响应格式。例如： 12345678{ \"code\":200, \"message\":\"success\", \"data\":{ \"sub\":\"admin\", ... }} 下面我们是我们通过以userNameAttributeName以 . 为分割符，提取用户信息实现，以下只展示部分代码，其余代码和DefaultOAuth2UserServicey源码相同。 首先我们新建工具类JsonHelper用于解析Json 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556@Slf4jpublic class JsonHelper { private static final JsonHelper.MapTypeReference MAP_TYPE = new JsonHelper.MapTypeReference(); private static ObjectMapper mapper; private JsonHelper() { } static { mapper = new ObjectMapper(); mapper.configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, false); } public static JsonNode getFirstNode(final JsonNode node, final String path) { JsonNode resultNode = null; if (path != null) { resultNode = getElement(node, path); } return resultNode; } public static JsonNode getElement(final JsonNode json, final String name) { if (json != null &amp;&amp; name != null) { JsonNode node = json; for (String nodeName : name.split(\"\\\\.\")) { if (node != null) { if (nodeName.matches(\"\\\\d+\")) { node = node.get(Integer.parseInt(nodeName)); } else { node = node.get(nodeName); } } } if (node != null) { return node; } } return null; } public static Map&lt;String, Object&gt; parseMap(String json) { try { return mapper.readValue(json, MAP_TYPE); } catch (JsonProcessingException e) { log.error(\"Cannot convert json to map\"); } return null; } private static class MapTypeReference extends TypeReference&lt;Map&lt;String, Object&gt;&gt; { private MapTypeReference() { } }} 新建DefaultJsonOAuth2UserService实现OAuth2UserService，添加多层JSON提取用户信息逻辑： 123456789101112131415161718192021222324public class DefaultJsonOAuth2UserService implements OAuth2UserService&lt;OAuth2UserRequest, OAuth2User&gt; { //... @Override public OAuth2User loadUser(OAuth2UserRequest userRequest) throws OAuth2AuthenticationException { //...省略部分代码 RequestEntity&lt;?&gt; request = this.requestEntityConverter.convert(userRequest); ResponseEntity&lt;JsonNode&gt; response = getResponse(userRequest, request); JsonNode responseBody = response.getBody(); //多层JSON提取用户信息属性 Map&lt;String, Object&gt; userAttributes = new HashMap&lt;&gt;(); if (userNameAttributeName.contains(\".\")) { String firstNodePath = userNameAttributeName.substring(0, userNameAttributeName.lastIndexOf(\".\")); userAttributes = this.extractUserAttribute(responseBody, firstNodePath); userNameAttributeName = userNameAttributeName.substring(firstNodePath.length() + 1); } else { userAttributes = JsonHelper.parseMap(responseBody.toString()); } //...省略部分代码 }} 如您需要参考详细代码，请查阅文末源码链接获取。 最后我们创建Controller类，使用thymeleaf引擎构建首页信息，不同权限信息看到首页列表结果不同： 1234567891011121314151617@Controllerpublic class HomeController { private static Map&lt;String, List&lt;String&gt;&gt; articles = new HashMap&lt;&gt;(); static { articles.put(\"ROLE_OPERATION\", Arrays.asList(\"Java\")); articles.put(\"ROLE_SYSTEM\", Arrays.asList(\"Java\", \"Python\", \"C++\")); } @GetMapping(\"/home\") public String home(Authentication authentication, Model model) { String authority = authentication.getAuthorities().iterator().next().getAuthority(); model.addAttribute(\"articles\", articles.get(authority)); return \"home\"; }} 测试我们启动服务后，访问http://127.0.0.1:8070/login， 首先使用用户名密码登录，您将会看到： 之后我们退出登录使，用OAuth2 登录，您将会看到不同信息： 结论我们使用OAuth2.0 授权协议上构建身份认证证明是可行的。但是我们不能忽略在这之间的陷阱。 令牌本身并不传递有关身份认证事件的信息。令牌可能是直接颁发给客户端的，使用的是无须用户交互的 OAuth 2.0 客户端凭据模式。 客户端都无法从访问令牌中得到关于用户及其登录状态的信息。OAuth 2.0 访问令牌的目标受众是资源服务器。（在本文中我们使用JWT访问令牌，通过自定义访问令牌信息使客户端服务获取用户权限等信息，但是OAuth2.0 协议中并没有定义访问令牌格式，我们仅是使用了JWT的特性来做到这一点。） 客户端可以出示访问令牌给资源服务获取用户信息，所以很容易就认为只要拥有一个有效的访问令牌，就能证明用户已登录，这一思路仅在某些情况下是正确的，即用户在授权服务器上完成身份认证，刚生成访问令牌的时候。（因为访问令牌有效期可能远长与身份认证会话有效期） 基于OAuth2.0的用户信息API的最大问题是，不同身份提供者实现用户信息API必然不同。用户的唯一标识可能是“user_id”，也可能是“sub”。 所以我们需要统一的OAuth2.0为基础的标准身份认证协议。OpenID Connect 是一个开放标准，它定义了一种使用 OAuth 2.0 执行用户身份认证的互通方式。这将在后续文章中介绍它。 与往常一样，本文中使用的源代码可在 GitHub 上获得。","link":"/2022/07/25/oauth2-login/"},{"title":"Spring Security 持久化OAuth2客户端","text":"Spring Security 持久化OAuth2客户端在之前文章中介绍过了客户端通过向授权服务器（使用Spring Authorization Server）请求授权并访问资源服务器受保护资源。在创建OAuth2客户端服务时，客户端注册通常从application.yml 文件中自动加载，Spring 自动配置使用OAuth2ClientProperties在spring.security.oauth2.client.registration.[registrationId]创建一个ClientRegistration并实例化ClientRegistrationRepository。 以下Spring自动配置OAuth2ClientRegistrationRepositoryConfiguration代码如下： 12345678910111213141516@Configuration( proxyBeanMethods = false)@EnableConfigurationProperties({OAuth2ClientProperties.class})@Conditional({ClientsConfiguredCondition.class})class OAuth2ClientRegistrationRepositoryConfiguration { OAuth2ClientRegistrationRepositoryConfiguration() { } @Bean @ConditionalOnMissingBean({ClientRegistrationRepository.class}) InMemoryClientRegistrationRepository clientRegistrationRepository(OAuth2ClientProperties properties) { List&lt;ClientRegistration&gt; registrations = new ArrayList(OAuth2ClientPropertiesRegistrationAdapter.getClientRegistrations(properties).values()); return new InMemoryClientRegistrationRepository(registrations); }} 如您所见，ClientRegistrationRepository默认实现并仅有一个实现类是InMemoryClientRegistrationRepository，它将ClientRegistration存储在内存中，而在生产环境中此方式可能会有一定局限性。 在本文中您将了解如何通过扩展ClientRegistrationRepository实现OAuth2客户端持久化。 OAuth2客户端服务实现在本节中，您将创建一个简单的OAuth2客户端服务，并通过数据库存储OAuth2客户端信息，现在看代码！ maven123456789101112131415161718192021222324252627282930313233343536373839&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;version&gt;2.6.7&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-jdbc&lt;/artifactId&gt; &lt;version&gt;2.6.7&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-security&lt;/artifactId&gt; &lt;version&gt;2.6.7&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-oauth2-client&lt;/artifactId&gt; &lt;version&gt;2.6.7&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webflux&lt;/artifactId&gt; &lt;version&gt;5.3.9&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;io.projectreactor.netty&lt;/groupId&gt; &lt;artifactId&gt;reactor-netty&lt;/artifactId&gt; &lt;version&gt;1.0.9&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;8.0.21&lt;/version&gt;&lt;/dependency&gt;... 配置首先让我们通过application.yml配置服务端口信息和数据库连接信息： 1234567891011server: port: 8070 spring: datasource: druid: db-type: mysql driver-class-name: com.mysql.cj.jdbc.Driver url: jdbc:mysql://localhost:3306/persistence_oauth2_client?createDatabaseIfNotExist=true&amp;useUnicode=true&amp;characterEncoding=UTF-8&amp;useSSL=false&amp;serverTimezone=Asia/Shanghai&amp;allowPublicKeyRetrieval=true username: &lt;&lt;username&gt;&gt; # 修改用户名 password: &lt;&lt;password&gt;&gt; # 修改密码 接下来我们根据ClientRegistration来创建数据库表用于存储OAuth2客户端信息： 1234567891011121314151617181920CREATE TABLE `oauth2_registered_client`( `registration_id` varchar(100) NOT NULL, `client_id` varchar(100) NOT NULL, `client_secret` varchar(200) DEFAULT NULL, `client_authentication_method` varchar(100) NOT NULL, `authorization_grant_type` varchar(100) NOT NULL, `client_name` varchar(200) DEFAULT NULL, `redirect_uri` varchar(1000) NOT NULL, `scopes` varchar(1000) NOT NULL, `authorization_uri` varchar(1000) DEFAULT NULL, `token_uri` varchar(1000) NOT NULL, `jwk_set_uri` varchar(1000) DEFAULT NULL, `issuer_uri` varchar(1000) DEFAULT NULL, `user_info_uri` varchar(1000) DEFAULT NULL, `user_info_authentication_method` varchar(100) DEFAULT NULL, `user_name_attribute_name` varchar(100) DEFAULT NULL, `configuration_metadata` varchar(2000) DEFAULT NULL, PRIMARY KEY (`registration_id`)) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci; 下面将是我们通过实现ClientRegistrationRepository扩展的JdbcClientRegistrationRepository： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354public class JdbcClientRegistrationRepository implements ClientRegistrationRepository { private static final String COLUMN_NAMES = \"registration_id,client_id,client_secret,client_authentication_method,authorization_grant_type,client_name,redirect_uri,scopes,authorization_uri,token_uri,jwk_set_uri,issuer_uri,user_info_uri,user_info_authentication_method,user_name_attribute_name,configuration_metadata\"; private static final String TABLE_NAME = \"oauth2_registered_client\"; private static final String LOAD_CLIENT_REGISTERED_SQL = \"SELECT \" + COLUMN_NAMES + \" FROM \" + TABLE_NAME + \" WHERE \"; private static final String INSERT_CLIENT_REGISTERED_SQL = \"INSERT INTO \" + TABLE_NAME + \"(\" + COLUMN_NAMES + \") VALUES(?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?)\"; private static final String UPDATE_CLIENT_REGISTERED_SQL = \"UPDATE \" + TABLE_NAME + \" SET client_id = ?,client_secret = ?,client_authentication_method = ?,authorization_grant_type = ?,client_name = ?,redirect_uri = ?,scopes = ?,authorization_uri = ?,token_uri = ?,jwk_set_uri = ?,issuer_uri = ?,user_info_uri = ?,user_info_authentication_method = ?,user_name_attribute_name = ? WHERE registration_id = ?\"; private final JdbcOperations jdbcOperations; private RowMapper&lt;ClientRegistration&gt; clientRegistrationRowMapper; private Function&lt;ClientRegistration, List&lt;SqlParameterValue&gt;&gt; clientRegistrationListParametersMapper; public JdbcClientRegistrationRepository(JdbcOperations jdbcOperations) { Assert.notNull(jdbcOperations, \"JdbcOperations can not be null\"); this.jdbcOperations = jdbcOperations; this.clientRegistrationRowMapper = new ClientRegistrationRowMapper(); this.clientRegistrationListParametersMapper = new ClientRegistrationParametersMapper(); } @Override public ClientRegistration findByRegistrationId(String registrationId) { Assert.hasText(registrationId, \"registrationId cannot be empty\"); return this.findBy(\"registration_id = ?\", registrationId); } private ClientRegistration findBy(String filter, Object... args) { List&lt;ClientRegistration&gt; result = this.jdbcOperations.query(LOAD_CLIENT_REGISTERED_SQL + filter, this.clientRegistrationRowMapper, args); return !result.isEmpty() ? result.get(0) : null; } public void save(ClientRegistration clientRegistration) { Assert.notNull(clientRegistration, \"clientRegistration cannot be null\"); ClientRegistration existingClientRegistration = this.findByRegistrationId(clientRegistration.getRegistrationId()); if (existingClientRegistration != null) { this.updateRegisteredClient(clientRegistration); } else { this.insertClientRegistration(clientRegistration); } } private void updateRegisteredClient(ClientRegistration clientRegistration) { List&lt;SqlParameterValue&gt; parameterValues = this.clientRegistrationListParametersMapper.apply(clientRegistration); PreparedStatementSetter statementSetter = new ArgumentPreparedStatementSetter(parameterValues.toArray()); this.jdbcOperations.update(UPDATE_CLIENT_REGISTERED_SQL, statementSetter); } private void insertClientRegistration(ClientRegistration clientRegistration) { List&lt;SqlParameterValue&gt; parameterValues = this.clientRegistrationListParametersMapper.apply(clientRegistration); PreparedStatementSetter statementSetter = new ArgumentPreparedStatementSetter(parameterValues.toArray()); this.jdbcOperations.update(INSERT_CLIENT_REGISTERED_SQL, statementSetter); } //...省略部分代码} 之后我们将创建SecurityConfig安全配置类，在此类中创建OAuth2 Client所需特定的Bean。首先我们将实例化上述自定义的JdbcClientRegistrationRepository： 1234@Beanpublic ClientRegistrationRepository clientRegistrationRepository(JdbcTemplate jdbcTemplate) { return new JdbcClientRegistrationRepository(jdbcTemplate);} ClientRegistration：表示使用 OAuth 2.0 或 OpenID Connect (OIDC) 注册的客户端。它包含有关客户端的所有基本信息，例如客户端 ID、客户端机密、授权类型和各种 URI。 ClientRegistrationRepository：这是一个包含ClientRegistrations并负责持久化。 接下来配置OAuth2AuthorizedClient管理类OAuth2AuthorizedClientService： 123456@Beanpublic OAuth2AuthorizedClientService authorizedClientService( JdbcTemplate jdbcTemplate, ClientRegistrationRepository clientRegistrationRepository) { return new JdbcOAuth2AuthorizedClientService(jdbcTemplate, clientRegistrationRepository);} OAuth2AuthorizedClient：表示授权客户端。这是一个包含客户端注册但添加身份验证信息的组合类。 OAuth2AuthorizedClientService：负责OAuth2AuthorizedClient在 Web 请求之间进行持久化。 定义JdbcOAuth2AuthorizedClientService需要创建所需数据表，你可以在OAuth2 Client Schema中获取表定义： 1234567891011121314CREATE TABLE oauth2_authorized_client( client_registration_id varchar(100) NOT NULL, principal_name varchar(200) NOT NULL, access_token_type varchar(100) NOT NULL, access_token_value blob NOT NULL, access_token_issued_at timestamp NOT NULL, access_token_expires_at timestamp NOT NULL, access_token_scopes varchar(1000) DEFAULT NULL, refresh_token_value blob DEFAULT NULL, refresh_token_issued_at timestamp DEFAULT NULL, created_at timestamp DEFAULT CURRENT_TIMESTAMP NOT NULL, PRIMARY KEY (client_registration_id, principal_name)); 接下来配置OAuth2AuthorizedClientRepository容器类： 12345@Beanpublic OAuth2AuthorizedClientRepository authorizedClientRepository( OAuth2AuthorizedClientService authorizedClientService) { return new AuthenticatedPrincipalOAuth2AuthorizedClientRepository(authorizedClientService);} OAuth2AuthorizedClientRepository:是一个容器类，用于在请求之间保存和持久化授权客户端。这里通过JdbcOAuth2AuthorizedClientService将客户端存储在数据库中。 接下来实例化包含授权流程的逻辑的管理器类： 1234567891011121314@BeanOAuth2AuthorizedClientManager authorizedClientManager(ClientRegistrationRepository clientRegistrationRepository, OAuth2AuthorizedClientRepository authorizedClientRepository) { OAuth2AuthorizedClientProvider authorizedClientProvider = OAuth2AuthorizedClientProviderBuilder .builder() .authorizationCode() .refreshToken() .build(); DefaultOAuth2AuthorizedClientManager authorizedClientManager = new DefaultOAuth2AuthorizedClientManager(clientRegistrationRepository, authorizedClientRepository); authorizedClientManager.setAuthorizedClientProvider(authorizedClientProvider); return authorizedClientManager;} OAuth2AuthorizedClientManager：是包含处理授权流程的逻辑的管理器类。最重要的是，它使用OAuth2AuthorizedClientProvider处理不同授权类型和 OAuth 2.0 提供者的实际请求逻辑。它还委托OAuth2AuthorizedClientRepository在客户端授权成功或失败时调用成功或失败处理程序。 现在让我们创建一个WebClient实例用于向资源服务器执行HTTP请求： 1234567@Bean WebClient webClient(OAuth2AuthorizedClientManager authorizedClientManager) { ServletOAuth2AuthorizedClientExchangeFilterFunction oauth2Client = new ServletOAuth2AuthorizedClientExchangeFilterFunction(authorizedClientManager); return WebClient.builder() .apply(oauth2Client.oauth2Configuration()) .build(); } 最后，我们将配置Spring Security安全配置： 123456789101112@Bean SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception { http .authorizeRequests(authorizeRequests -&gt; authorizeRequests.anyRequest().authenticated() ) .formLogin(login -&gt; { login.loginPage(\"/login\").permitAll(); }) .oauth2Client(withDefaults()); return http.build(); } 这里配置所有请求需要认证授权，提供Form表单认证方式，并通过thymeleaf自定义登录模版，此处代码并不再本文讲解范围内，以下将不展示具体细节。 访问资源列表我们将创建一个PersistenceClientController，并使用WebClient向资源服务器发起HTTP请求： 12345678910111213141516@RestControllerpublic class PersistenceClientController { @Autowired private WebClient webClient; @GetMapping(value = \"/client/test\") public List&lt;String&gt; getArticles(@RegisteredOAuth2AuthorizedClient(\"messaging-client-authorization-code\") OAuth2AuthorizedClient authorizedClient) { return this.webClient .get() .uri(\"http://127.0.0.1:8090/resource/article\") .attributes(oauth2AuthorizedClient(authorizedClient)) .retrieve() .bodyToMono(List.class) .block(); }} 在本文中，您看到了OAuth2客户端服务持久化到数据库的实现方法，对于其他授权服务器和资源服务器配置将不再讲解，如果您感兴趣可以参考 此文章将JWT与Spring Security OAuth2结合使用。 结论与往常一样，本文中使用的源代码可在 GitHub 上获得。","link":"/2022/07/03/persisrence-oauth2-client/"},{"title":"设计模式-单例模式","text":"单例模式单例模式是设计模式中比较简单的模式，也是很常用的模式，其定义如下： 确保某一个类只有一个实例，而且自行实例化并向整个系统提供这个实例。 通用类图如下： 通过私有化构造函数确保在一个应用中只有一个实例，并提供静态方法发布对象。 单例模式通用代码（也被称为饿汉式）： 12345678910111213141516public class Singleton { private static final Singleton singleton= new Singleton(); //限制多个对象 private Singleton (){} //通过该方法获得实例对象 public static Singleton getSingleton() { return singleton; } //在类中其他方法，尽量是static public static void doSomething(){ ... }} 单例模式的优点 减少内存开支，特别是一个对象频繁的创建和销毁时。 减少系统性能开销，当一个对象的产生需要比较多的资源时，可以通过启动时产生一个单例对象。 单例模式可以避免对资产的多重占用。 单例模式可以在系统设置全局的访问点，优化和共享资源访问。 单例模式的缺点 单例模式对测试不利，在并行开发中，如果单例模式没有完成，是不能进行测试的，因为没有接口也不能mock的方式虚拟一个对象 单例模式与单一职责原则有冲突，一个类应该只实现一个逻辑，单例模式把“要单例”和业务逻辑合在一个类中 单例模式使用场景系统中要求一个类只有一个对象，当存在多个对象时会产生错误影响，可以使用单例模式。 要求生成唯一序列号的环境 在项目中需要一个共享访问点和共享数据 创建一个对象需要消耗很多资源。 需要定义大量的静态常量和静态方法（如工具类） 单例模式的注意事项在高并发情况下，单例模式存在线程同步问题，如下面的一种单例模式实现方式（也称为懒汉式）： 12345678910111213public class Singleton { private static Singleton singleton = null; //限制产生多个对象 private Singleton(){} public static Singleton getSingleton() { if(singleton == null){ singleton = new Singleton(); } return singleton; }} 在并发量增加时可能会出现多个实例，如一个线程A执行到singleton = new Singleton()，但是还没有获得对象，第二个线程B也在执行，执行到singleton == null判断，判断条件为真，于是运行下去也创建了一个对象。 解决线程不安全问题方法有很多，一使用饿汉式的实现方式，静态变量在类加载时初始化，类加载过程是线程安全的，所以饿汉式没有线程安全问题；二是使用Java的锁机制，以下代码示例单例模式（懒汉式）的双重检锁机制： 1234567891011121314151617public class Singleton { private static volatile Singleton singleton = null; //限制产生多个对象 private Singleton(){} public static Singleton getSingleton() { if (singleton == null) { synchronized (Singleton.class) { if (singleton == null) { singleton = new Singleton(); } } } return singleton; }} 总之单例模式比较简单而且应用非常广泛，在Spring框架中每个Bean默认就是单例的。 结论与往常一样，本文中使用的源代码可在 GitHub 上获得。","link":"/2022/05/11/singleton-pattern/"},{"title":"SpringGateway使用SpringSecurity防止CSRF攻击","text":"SpringGateway使用SpringSecurity防止CSRF攻击配置CSRF保护123456@Beanpublic SecurityWebFilterChain springSecurityFilterChain(ServerHttpSecurity http) { http .csrf(csrf -&gt; csrf.csrfTokenRepository(CookieServerCsrfTokenRepository.withHttpOnlyFalse())) return http.build();} 以上通过Cookie持久化XSRF-TOKEN值，jS读取cookie中的值发起请求时需携带X-XSRF-TOKEN请求头，默认情况GET，HEAD，TRACE，OPTIONS请求方式是放行的，具体实现在DefaultRequireCsrfProtectionMatcher类。如果需要特殊定制，可以自定义实现类实现ServerWebExchangeMatcher,并替换默认DefaultRequireCsrfProtectionMatcher: 1234567@Bean public SecurityWebFilterChain springSecurityFilterChain(ServerHttpSecurity http) { http .csrf(csrf -&gt; csrf.csrfTokenRepository(CookieServerCsrfTokenRepository.withHttpOnlyFalse()) .requireCsrfProtectionMatcher(new CustomServerWebExchangeMatcher()); return http.build(); } CookieServerCsrfTokenRepository does not add cookie在我们按照上述配置分别测试GET请求和POST请求时，发现GET请求响应cookie中并没有XSRF-TOKEN，原因在响应式编程中CsrfToken并没有被订阅。具体问题解析在Spring Security issues中找到答案；最后也提供了解决方式： 12345678910111213141516@Slf4j@Componentpublic class CsrfHelperFilter implements WebFilter { @Override public Mono&lt;Void&gt; filter(ServerWebExchange exchange, WebFilterChain chain) { String key = CsrfToken.class.getName(); Mono&lt;CsrfToken&gt; csrfToken = null != exchange.getAttribute(key) ? exchange.getAttribute(key) : Mono.empty(); return csrfToken.doOnSuccess(token -&gt; { ResponseCookie cookie = ResponseCookie.from(\"XSRF-TOKEN\", token.getToken()).maxAge(Duration.ofHours(1)) .httpOnly(false).path(\"/\").build(); log.debug(\"Cookie: {}\", cookie); exchange.getResponse().getCookies().add(\"XSRF-TOKEN\", cookie); }).then(chain.filter(exchange)); }} 结论与往常一样，本文中使用的源代码可在 GitHub 上获得。","link":"/2022/06/22/spring-gateway-csrf/"},{"title":"注解@PathVariable、@RequestParam、@RequestBody、@RequestHeader讲解","text":"@PathVariable绑定请求参数，当@RequestMapping(value=”/get/{id}”），可以获取url格式/get/{id}中{id}的值 属性 说明 value 指定request参数名 name 指定request参数名（与value二选一） required 是否需要该参数。 默认为true，如果请求中缺少参数，则会引发异常 当url为 get/{id}/{name} 12@RequestMapping(\"/get/{id}/{name}\")public String get(@PathVariable Integer id,@PathVariable String name) 当需要对url变量进行更加精确的定义时，可以定义正则表达式进行更精确地控制，定义语法是{变量名: 正则表达式} 12@RequestMapping(\"/get/{name:[a-zA-Z0-9]+}\")public String get(@PathVariable String name) 如此设置URL变量规则后，不合法的URL则不会被处理，直接由SpringMVC框架返回404NotFound。 @RequestParam绑定来自请求url中的参数，可以获取url格式：?username=”zhangsan”。 属性 说明 value 指定request参数名 name 指定request参数名（与value二选一） required 是否需要该参数。 默认为true，如果请求中缺少参数，则会引发异常 defaultValue 未提供request参数或具有空值时用作后备的默认值,当设置默认值时，required隐式的设为了false 如果在传递参数时url是?userName=zhangsan&amp;userName=wangwu，即两个同名参数，后台可以用以下方法接收： 123public String getUserName(@RequestParam(value=\"userName\") String [] userNames)//或者是public String getUserName(@RequestParam(value=\"list\") List&lt;String&gt; list) Get/POST请求测试12345678public String get(@RequestParam Map map)//在url中？后面添加参数可以接收public String get(@RequestParam String id)//在url中？后面添加参数可以接收 public String get(@RequestParam Object object)//参数接收不到 @RequestBody绑定来自HTTP请求体 的参数 @RequestBody用来处理 Content-Type 为 application/json、application/xml编码的内容 属性 说明 required 是否需要该参数。 默认为true，如果请求中缺少参数，则会引发异常 GET/POST 请求测试12345678public String get(@RequestBody Map map)//json参数可以接收public String get(@RequestBody String id)//json参数可以接收,但是字符串接收的是整个json格式的字符串,如打印：{\"id\":3,\"name\":\"ddd\"} public String get(@RequestBody Object object)//json参数可以接收 指定实体类中的属性对应json中的key值@JsonProperty、@JsonAlias 1234567@Datapublic class Employee { @JsonProperty(value = \"ids\") //json中的key为ids可以识别，key为id不能识别 private String id; @JsonAlias(value = {\"NAME\",\"ii\"}) //json中的key为NAME、ii、name都能识别 private String name;} @RequestHeader从Http请求头中提取指定的某个请求头。 属性 说明 value 指定请求头中的key name 指定请求头中的key（与value二选一） required 是否需要该参数。 默认为true，如果请求中缺少参数，则会引发异常 defaultValue 未提供request参数或具有空值时用作后备的默认值,当设置默认值时，required隐式的设为了false 1public String get(@RequestHeader(value = \"Content-Type\") String contextType){}","link":"/2022/05/09/spring-mvc-annotation/"},{"title":"Spring项目的resources目录下的文件读取","text":"src/main/resources和src/test/resources下的资源读取方式1. 一般maven会将spring工程编译到target文件夹下，/target/classes就是其根目录。而src/main/resources下的文件被复制到了这个classes文件夹下。 2. maven会将src/test/java文件夹下的代码编译到target/test-classes文件夹下。同样的，如果src/test/resources下有资源文件的话，就复制到target/test-classes文件夹下。 测试代码运行时，优先使用test-classes文件夹下的资源文件，如果不存在，再使用classes文件夹下的资源文件。 前两种底层代码都是通过类加载器读取流 1. 使用org.springframework.core.io.ClassPathResource读取，开发环境和生产环境(Linux下jar包运行读取)都能读取。 12345678910Resource resource=new ClassPathResource(\"3.png\");InputStream fis = resource.getInputStream();OutputStream fos=new FileOutputStream(\"E://3.png\");int len=0;byte[] buf=new byte[1024];while((len=fis.read(buf,0,buf.length))!=-1){ fos.write(buf,0,len);}fos.close();fis.close(); 2. 使用流的方式来读取，两种方式，开发环境和生产环境(Linux下jar包运行读取)都能读取。 方式一： 123456789InputStream fis = this.getClass().getResourceAsStream(\"/3.png\");OutputStream fos=new FileOutputStream(\"E://3.png\");int len=0;byte[] buf=new byte[1024];while((len=fis.read(buf,0,buf.length))!=-1){ fos.write(buf,0,len);}fos.close();fis.close(); 方式二： 123456789InputStream fis = Thread.currentThread().getContextClassLoader().getResourceAsStream(\"/3.png\");OutputStream fos=new FileOutputStream(\"E://3.png\");int len=0;byte[] buf=new byte[1024];while((len=fis.read(buf,0,buf.length))!=-1){ fos.write(buf,0,len);}fos.close();fis.close(); 3. 使用org.springframework.core.io.ResourceLoader 读取，开发环境和生产环境(Linux下jar包运行读取)都能读取。 12345678910111213141516@AutowiredResourceLoader resourceLoader;@Testpublic void resourceLoaderTest() throws IOException { Resource resource = resourceLoader.getResource(\"classpath:3.png\"); InputStream fis = resource.getInputStream(); OutputStream fos=new FileOutputStream(\"E://3.png\"); int len=0; byte[] buf=new byte[1024]; while((len=fis.read(buf,0,buf.length))!=-1){ fos.write(buf,0,len); } fos.close(); fis.close();} 4. 使用File file=new File(“src/main/resources/file.txt”); 读取，只能在开发环境中读取，不能再生产环境中读取(Linux下jar包运行读取)。 1234567891011File file=new File(\"src/main/resources/3.png\");InputStream fis=new FileInputStream(file);OutputStream fos=new FileOutputStream(\"E://3.png\");int len=0;byte[] buf=new byte[1024];while ((len=fis.read(buf,0,buf.length))!=-1){ fos.write(buf,0,len); System.out.println(\"---\");}fos.close();fis.close(); 5. 使用org.springframework.util.ResourceUtils 读取，只能在开发环境中读取，不能再生产环境中读取(Linux下jar包运行读取)。 12345678910File file = ResourceUtils.getFile(\"src/main/resources/3.png\");InputStream fis=new FileInputStream(file);OutputStream fos=new FileOutputStream(\"E://3.png\");int len=0;byte[] buf=new byte[1024];while((len=fis.read(buf,0,buf.length))!=-1){ fos.write(buf,0,len);}fos.close();fis.close(); 结论与往常一样，本文中使用的源代码可在 GitHub 上获得。","link":"/2022/05/09/spring-read-resource/"},{"title":"将Spring Cloud Gateway 与OAuth2模式一起使用","text":"将Spring Cloud Gateway 与OAuth2模式一起使用概述Spring Cloud Gateway是一个构建在 Spring 生态之上的 API Gateway。 建立在Spring Boot 2.x、Spring WebFlux和Project Reactor之上。 本节中您将使用Spring Cloud Gateway将请求路由到Servlet API服务。 本文您将学到： OpenID Connect 身份验证 - 用于用户身份验证 令牌中继 - Spring Cloud Gateway API网关充当客户端将令牌转发到资源请求上 先决条件： Java 8+ MySQL Redis OpenID Connect身份验证OpenID Connect 定义了一种基于 OAuth2 授权代码流的最终用户身份验证机制。下图是Spring Cloud Gateway与授权服务进行身份验证完整流程，为了清楚起见，其中一些参数已被省略。 创建授权服务本节中我们将使用Spring Authorization Server 构建授权服务，支持OAuth2协议与OpenID Connect协议。同时我们还将使用RBAC0基本权限模型控制访问权限。并且该授权服务同时作为OAuth2客户端支持Github第三方登录。 相关数据库表结构我们创建了基本RBAC0权限模型用于本文示例讲解，并提供了OAuth2授权服务持久化存储所需表结构和OAuth2客户端持久化存储所需表结构。通过oauth2_client_role定义外部系统角色与本平台角色映射关系。涉及相关创建表及初始化数据的SQL语句可以从这里获取。 角色说明本节中授权服务默认提供两个角色，以下是角色属性及访问权限： read write ROLE_ADMIN ✅ ✅ ROLE_OPERATION ✅ ❎ Maven依赖12345678910111213141516171819202122232425262728293031323334353637383940414243444546&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-security&lt;/artifactId&gt; &lt;version&gt;2.6.7&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.security&lt;/groupId&gt; &lt;artifactId&gt;spring-security-oauth2-authorization-server&lt;/artifactId&gt; &lt;version&gt;0.3.1&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-oauth2-client&lt;/artifactId&gt; &lt;version&gt;2.6.7&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;version&gt;2.6.7&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-jdbc&lt;/artifactId&gt; &lt;version&gt;2.6.7&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-jpa&lt;/artifactId&gt; &lt;version&gt;2.6.7&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;8.0.21&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.2.3&lt;/version&gt;&lt;/dependency&gt; 配置首先我们从application.yml配置开始，这里我们指定了端口号与MySQL连接配置： 1234567891011server: port: 8080spring: datasource: druid: db-type: mysql driver-class-name: com.mysql.cj.jdbc.Driver url: jdbc:mysql://localhost:3306/oauth2server?createDatabaseIfNotExist=true&amp;useUnicode=true&amp;characterEncoding=UTF-8&amp;useSSL=false&amp;serverTimezone=Asia/Shanghai&amp;allowPublicKeyRetrieval=true username: &lt;&lt;username&gt;&gt; # 修改用户名 password: &lt;&lt;password&gt;&gt; # 修改密码 接下来我们将创建AuthorizationServerConfig，用于配置OAuth2及OIDC所需Bean，首先我们将新增OAuth2客户端信息，并持久化到数据库： 12345678910111213141516171819202122232425262728293031323334@Beanpublic RegisteredClientRepository registeredClientRepository(JdbcTemplate jdbcTemplate) { RegisteredClient registeredClient = RegisteredClient.withId(\"relive-messaging-oidc\") .clientId(\"relive-client\") .clientSecret(\"{noop}relive-client\") .clientAuthenticationMethods(s -&gt; { s.add(ClientAuthenticationMethod.CLIENT_SECRET_POST); s.add(ClientAuthenticationMethod.CLIENT_SECRET_BASIC); }) .authorizationGrantType(AuthorizationGrantType.AUTHORIZATION_CODE) .authorizationGrantType(AuthorizationGrantType.REFRESH_TOKEN) .redirectUri(\"http://127.0.0.1:8070/login/oauth2/code/messaging-gateway-oidc\") .scope(OidcScopes.OPENID) .scope(OidcScopes.PROFILE) .scope(OidcScopes.EMAIL) .scope(\"read\") .clientSettings(ClientSettings.builder() .requireAuthorizationConsent(false) //不需要授权同意 .requireProofKey(false) .build()) .tokenSettings(TokenSettings.builder() .accessTokenFormat(OAuth2TokenFormat.SELF_CONTAINED) // 生成JWT令牌 .idTokenSignatureAlgorithm(SignatureAlgorithm.RS256) .accessTokenTimeToLive(Duration.ofSeconds(30 * 60))//accessTokenTimeToLive：access_token有效期 .refreshTokenTimeToLive(Duration.ofSeconds(60 * 60))//refreshTokenTimeToLive：refresh_token有效期 .reuseRefreshTokens(true) .build()) .build(); JdbcRegisteredClientRepository registeredClientRepository = new JdbcRegisteredClientRepository(jdbcTemplate); registeredClientRepository.save(registeredClient); return registeredClientRepository;} 其次我们将创建授权过程中所需持久化容器类： 12345678910@Beanpublic OAuth2AuthorizationService authorizationService(JdbcTemplate jdbcTemplate, RegisteredClientRepository registeredClientRepository) { return new JdbcOAuth2AuthorizationService(jdbcTemplate, registeredClientRepository);} @Beanpublic OAuth2AuthorizationConsentService authorizationConsentService(JdbcTemplate jdbcTemplate, RegisteredClientRepository registeredClientRepository) { return new JdbcOAuth2AuthorizationConsentService(jdbcTemplate, registeredClientRepository);} 授权服务器需要其用于令牌的签名密钥，让我们生成一个 2048 字节的 RSA 密钥： 12345678910111213141516171819202122232425262728293031323334353637383940@Beanpublic JWKSource&lt;SecurityContext&gt; jwkSource() { RSAKey rsaKey = Jwks.generateRsa(); JWKSet jwkSet = new JWKSet(rsaKey); return (jwkSelector, securityContext) -&gt; jwkSelector.select(jwkSet);}static class Jwks { private Jwks() { } public static RSAKey generateRsa() { KeyPair keyPair = KeyGeneratorUtils.generateRsaKey(); RSAPublicKey publicKey = (RSAPublicKey) keyPair.getPublic(); RSAPrivateKey privateKey = (RSAPrivateKey) keyPair.getPrivate(); return new RSAKey.Builder(publicKey) .privateKey(privateKey) .keyID(UUID.randomUUID().toString()) .build(); }}static class KeyGeneratorUtils { private KeyGeneratorUtils() { } static KeyPair generateRsaKey() { KeyPair keyPair; try { KeyPairGenerator keyPairGenerator = KeyPairGenerator.getInstance(\"RSA\"); keyPairGenerator.initialize(2048); keyPair = keyPairGenerator.generateKeyPair(); } catch (Exception ex) { throw new IllegalStateException(ex); } return keyPair; }} 接下来我们将创建用于OAuth2授权的SecurityFilterChain，SecurityFilterChain是Spring Security提供的过滤器链，Spring Security的认证授权功能都是通过滤器完成： 123456789101112131415161718192021222324@Bean@Order(Ordered.HIGHEST_PRECEDENCE)public SecurityFilterChain authorizationServerSecurityFilterChain(HttpSecurity http) throws Exception { OAuth2AuthorizationServerConfigurer&lt;HttpSecurity&gt; authorizationServerConfigurer = new OAuth2AuthorizationServerConfigurer&lt;&gt;(); //配置OIDC authorizationServerConfigurer.oidc(Customizer.withDefaults()); RequestMatcher endpointsMatcher = authorizationServerConfigurer.getEndpointsMatcher(); return http.requestMatcher(endpointsMatcher) .authorizeRequests((authorizeRequests) -&gt; { ((ExpressionUrlAuthorizationConfigurer.AuthorizedUrl) authorizeRequests.anyRequest()).authenticated(); }).csrf((csrf) -&gt; { csrf.ignoringRequestMatchers(new RequestMatcher[]{endpointsMatcher}); }).apply(authorizationServerConfigurer) .and() .oauth2ResourceServer(OAuth2ResourceServerConfigurer::jwt) .exceptionHandling(exceptions -&gt; exceptions. authenticationEntryPoint(new LoginUrlAuthenticationEntryPoint(\"/login\"))) .apply(authorizationServerConfigurer) .and() .build();} 上述我们配置了OAuth2和OpenID Connect默认配置，并将为认证请求重定向到登录页，同时我们还启用了Spring Security提供的OAuth2资源服务配置，该配置用于保护OpenID Connect中/userinfo用户信息端点。 在启用Spring Security的OAuth2资源服务配置时我们指定了JWT验证，所以我们需要在application.yml中指定jwk-set-uri或声明式添加JwtDecoder，下面我们使用声明式配置： 1234@Beanpublic JwtDecoder jwtDecoder(JWKSource&lt;SecurityContext&gt; jwkSource) { return OAuth2AuthorizationServerConfiguration.jwtDecoder(jwkSource);} 接下来我们将自定义Access Token，在本示例中我们使用RBAC0权限模型，所以我们将Access Token中scope替换为当前用户所属角色的权限(permissionCode)： 1234567891011121314151617181920@Configuration(proxyBeanMethods = false)public class AccessTokenCustomizerConfig { @Autowired RoleRepository roleRepository; @Bean public OAuth2TokenCustomizer&lt;JwtEncodingContext&gt; tokenCustomizer() { return (context) -&gt; { if (OAuth2TokenType.ACCESS_TOKEN.equals(context.getTokenType())) { context.getClaims().claims(claim -&gt; { claim.put(\"scope\", roleRepository.findByRoleCode(context.getPrincipal().getAuthorities().stream() .map(GrantedAuthority::getAuthority).findFirst().orElse(\"ROLE_OPERATION\")) .getPermissions().stream().map(Permission::getPermissionCode).collect(Collectors.toSet())); }); } }; }} RoleRepository属于role表持久层对象，在本示例中选用JPA框架，相关代码将不在文中展示，如果您并不了解JPA使用，可以使用Mybatis替代。 下面我们将配置授权服务Form表单认证方式： 123456789101112@BeanSecurityFilterChain defaultSecurityFilterChain(HttpSecurity http) throws Exception { http .authorizeRequests(authorizeRequests -&gt; authorizeRequests.anyRequest().authenticated() ) .formLogin(withDefaults()) ... return http.build();} 接下来我们将创建JdbcUserDetailsService 实现 UserDetailsService，用于在认证过程中查找登录用户的密码及权限信息，至于为什么需要实现UserDetailsService，感兴趣可以查看UsernamePasswordAuthenticationFilter -&gt; ProviderManager -&gt; DaoAuthenticationProvider 源码，在DaoAuthenticationProvider中通过调用UserDetailsService#loadUserByUsername(String username)获取用户信息。 1234567891011121314151617181920@RequiredArgsConstructorpublic class JdbcUserDetailsService implements UserDetailsService { private final UserRepository userRepository; @Override public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException { com.relive.entity.User user = userRepository.findUserByUsername(username); if (ObjectUtils.isEmpty(user)) { throw new UsernameNotFoundException(\"user is not found\"); } if (CollectionUtils.isEmpty(user.getRoleList())) { throw new UsernameNotFoundException(\"role is not found\"); } Set&lt;SimpleGrantedAuthority&gt; authorities = user.getRoleList().stream().map(Role::getRoleCode) .map(SimpleGrantedAuthority::new).collect(Collectors.toSet()); return new User(user.getUsername(), user.getPassword(), authorities); }} 并将它注入到Spring中： 1234@BeanUserDetailsService userDetailsService(UserRepository userRepository) { return new JdbcUserDetailsService(userRepository);} 在尝试请求未认证接口将会引导用户到登录页面并提示输入用户名密码，结果如下： 用户通常需要使用多个平台，这些平台由不同组织提供和托管。 这些用户可能需要使用每个平台的特定（和不同）的凭据。当用户拥有许多不同的凭据时，他们常常会忘记登录凭据。 联合身份验证是使用外部系统对用户进行身份验证。这可以与Google，Github或任何其他身份提供商一起使用。在这里，我将使用Github进行用户身份验证和数据同步管理。 Github身份认证首先我们将配置Github客户端信息，你只需要更改其中clientId和clientSecret。其次我们将使用Spring Security 持久化OAuth2客户端 文中介绍的JdbcClientRegistrationRepository持久层容器类将GitHub客户端信息存储在数据库中： 12345678910111213141516171819@BeanClientRegistrationRepository clientRegistrationRepository(JdbcTemplate jdbcTemplate) { JdbcClientRegistrationRepository jdbcClientRegistrationRepository = new JdbcClientRegistrationRepository(jdbcTemplate); ClientRegistration clientRegistration = ClientRegistration.withRegistrationId(\"github\") .clientId(\"123456\") .clientSecret(\"123456\") .clientAuthenticationMethod(ClientAuthenticationMethod.CLIENT_SECRET_BASIC) .authorizationGrantType(AuthorizationGrantType.AUTHORIZATION_CODE) .redirectUri(\"{baseUrl}/{action}/oauth2/code/{registrationId}\") .scope(new String[]{\"read:user\"}) .authorizationUri(\"https://github.com/login/oauth/authorize\") .tokenUri(\"https://github.com/login/oauth/access_token\") .userInfoUri(\"https://api.github.com/user\") .userNameAttributeName(\"login\") .clientName(\"GitHub\").build(); jdbcClientRegistrationRepository.save(clientRegistration); return jdbcClientRegistrationRepository;} 接下来我们将实例化OAuth2AuthorizedClientService和OAuth2AuthorizedClientRepository： OAuth2AuthorizedClientService：负责OAuth2AuthorizedClient在 Web 请求之间进行持久化。 OAuth2AuthorizedClientRepository：用于在请求之间保存和持久化授权客户端。 12345678910111213@BeanOAuth2AuthorizedClientService authorizedClientService( JdbcTemplate jdbcTemplate, ClientRegistrationRepository clientRegistrationRepository) { return new JdbcOAuth2AuthorizedClientService(jdbcTemplate, clientRegistrationRepository);}@BeanOAuth2AuthorizedClientRepository authorizedClientRepository( OAuth2AuthorizedClientService authorizedClientService) { return new AuthenticatedPrincipalOAuth2AuthorizedClientRepository(authorizedClientService);} 对于每个使用Github登录的用户，我们都要分配平台的角色以控制他们可以访问哪些资源，在此我们将新建AuthorityMappingOAuth2UserService类授予用户角色： 123456789101112131415161718192021222324252627282930@RequiredArgsConstructorpublic class AuthorityMappingOAuth2UserService implements OAuth2UserService&lt;OAuth2UserRequest, OAuth2User&gt; { private DefaultOAuth2UserService delegate = new DefaultOAuth2UserService(); private final OAuth2ClientRoleRepository oAuth2ClientRoleRepository; @Override public OAuth2User loadUser(OAuth2UserRequest userRequest) throws OAuth2AuthenticationException { DefaultOAuth2User oAuth2User = (DefaultOAuth2User) delegate.loadUser(userRequest); Map&lt;String, Object&gt; additionalParameters = userRequest.getAdditionalParameters(); Set&lt;String&gt; role = new HashSet&lt;&gt;(); if (additionalParameters.containsKey(\"authority\")) { role.addAll((Collection&lt;? extends String&gt;) additionalParameters.get(\"authority\")); } if (additionalParameters.containsKey(\"role\")) { role.addAll((Collection&lt;? extends String&gt;) additionalParameters.get(\"role\")); } Set&lt;SimpleGrantedAuthority&gt; mappedAuthorities = role.stream() .map(r -&gt; oAuth2ClientRoleRepository.findByClientRegistrationIdAndRoleCode(userRequest.getClientRegistration().getRegistrationId(), r)) .map(OAuth2ClientRole::getRole).map(Role::getRoleCode).map(SimpleGrantedAuthority::new) .collect(Collectors.toSet()); //当没有指定客户端角色，则默认赋予最小权限ROLE_OPERATION if (CollectionUtils.isEmpty(mappedAuthorities)) { mappedAuthorities = new HashSet&lt;&gt;( Collections.singletonList(new SimpleGrantedAuthority(\"ROLE_OPERATION\"))); } String userNameAttributeName = userRequest.getClientRegistration().getProviderDetails().getUserInfoEndpoint().getUserNameAttributeName(); return new DefaultOAuth2User(mappedAuthorities, oAuth2User.getAttributes(), userNameAttributeName); }} 我们可以看到从authority和role属性中获取权限信息，在通过OAuth2ClientRoleRepository查找映射到本平台的角色属性。 注意：authority和role是由平台自定义属性，与OAuth2协议与Open ID Connect 协议无关，在生产环境中你可以与外部系统协商约定一个属性来传递权限信息。 OAuth2ClientRoleRepository为oauth2_client_role表持久层容器类，由JPA实现。 对于未获取到预先定义的映射角色信息，我们将赋予默认ROLE_OPERATION最小权限角色。而对于GitHub登录的用户来说，也将被赋予ROLE_OPERATION角色。 针对GitHub认证成功并且首次登录的用户我们将获取用户信息并持久化到user表中,这里我们实现AuthenticationSuccessHandler并增加持久化用户逻辑： 1234567891011121314151617181920212223public final class SavedUserAuthenticationSuccessHandler implements AuthenticationSuccessHandler { private final AuthenticationSuccessHandler delegate = new SavedRequestAwareAuthenticationSuccessHandler(); private Consumer&lt;OAuth2User&gt; oauth2UserHandler = (user) -&gt; { }; @Override public void onAuthenticationSuccess(HttpServletRequest request, HttpServletResponse response, Authentication authentication) throws IOException, ServletException { if (authentication instanceof OAuth2AuthenticationToken) { if (authentication.getPrincipal() instanceof OAuth2User) { this.oauth2UserHandler.accept((OAuth2User) authentication.getPrincipal()); } } this.delegate.onAuthenticationSuccess(request, response, authentication); } public void setOauth2UserHandler(Consumer&lt;OAuth2User&gt; oauth2UserHandler) { this.oauth2UserHandler = oauth2UserHandler; }} 我们将通过setOauth2UserHandler(Consumer oauth2UserHandler)方法将UserRepositoryOAuth2UserHandler注入到SavedUserAuthenticationSuccessHandler中，UserRepositoryOAuth2UserHandler定义了具体持久层操作： 123456789101112131415161718192021@Component@RequiredArgsConstructorpublic final class UserRepositoryOAuth2UserHandler implements Consumer&lt;OAuth2User&gt; { private final UserRepository userRepository; private final RoleRepository roleRepository; @Override public void accept(OAuth2User oAuth2User) { DefaultOAuth2User defaultOAuth2User = (DefaultOAuth2User) oAuth2User; if (this.userRepository.findUserByUsername(oAuth2User.getName()) == null) { User user = new User(); user.setUsername(defaultOAuth2User.getName()); Role role = roleRepository.findByRoleCode(defaultOAuth2User.getAuthorities() .stream().map(GrantedAuthority::getAuthority).findFirst().orElse(\"ROLE_OPERATION\")); user.setRoleList(Arrays.asList(role)); userRepository.save(user); } }} 我们通过defaultOAuth2User.getAuthorities()获取到映射后的角色信息，并将其与用户信息存储到数据库中。 UserRepository和RoleRepository为持久化容器类。 最后我们向SecurityFilterChain加入OAuth2 Login配置： 12345678910111213141516171819@AutowiredUserRepositoryOAuth2UserHandler userHandler;@BeanSecurityFilterChain defaultSecurityFilterChain(HttpSecurity http) throws Exception { http .authorizeRequests(authorizeRequests -&gt; authorizeRequests.anyRequest().authenticated() ) .oauth2Login(oauth2login -&gt; { SavedUserAuthenticationSuccessHandler successHandler = new SavedUserAuthenticationSuccessHandler(); successHandler.setOauth2UserHandler(userHandler); oauth2login.successHandler(successHandler); }); ... return http.build();} 创建Spring Cloud Gateway应用程序本节中我们将在Spring Cloud Gateway中通过Spring Security OAuth2 Login 启用OpenID Connect身份验证，并将Access Token中继到下游服务。 Maven依赖123456789101112131415161718192021222324252627282930&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-gateway&lt;/artifactId&gt; &lt;version&gt;3.1.2&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-oauth2-client&lt;/artifactId&gt; &lt;version&gt;2.6.7&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt; &lt;version&gt;2.6.7&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.session&lt;/groupId&gt; &lt;artifactId&gt;spring-session-data-redis&lt;/artifactId&gt; &lt;version&gt;2.6.3&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;io.netty&lt;/groupId&gt; &lt;artifactId&gt;netty-all&lt;/artifactId&gt; &lt;version&gt;4.1.76.Final&lt;/version&gt;&lt;/dependency&gt; 配置首先我们在application.yml添加以下属性： 123456server: port: 8070 servlet: session: cookie: name: GATEWAY-CLIENT 这里指定了cookie name为GATEWAY-CLIENT，避免与授权服务JSESSIONID冲突。 通过Spring Cloud Gateway路由到资源服务器： 1234567891011121314spring: cloud: gateway: discovery: locator: enabled: true routes: - id: resource-server uri: http://127.0.0.1:8090 predicates: Path=/resource/** filters: - TokenRelay TokenRelay 过滤器将提取存储在用户会话中的访问令牌，并将其作为Authorization标头添加到传出请求中。这允许下游服务对请求进行身份验证。 我们将在application.yml中添加OAuth2客户端信息： 12345678910111213141516171819202122spring: security: oauth2: client: registration: messaging-gateway-oidc: provider: gateway-client-provider client-id: relive-client client-secret: relive-client authorization-grant-type: authorization_code redirect-uri: \"{baseUrl}/login/oauth2/code/{registrationId}\" scope: - openid - profile client-name: messaging-gateway-oidc provider: gateway-client-provider: authorization-uri: http://127.0.0.1:8080/oauth2/authorize token-uri: http://127.0.0.1:8080/oauth2/token jwk-set-uri: http://127.0.0.1:8080/oauth2/jwks user-info-uri: http://127.0.0.1:8080/userinfo user-name-attribute: sub OpenID Connect 使用一个特殊的权限范围值 openid 来控制对 UserInfo 端点的访问，其他信息与上节中授权服务注册客户端信息参数保持一致。 我们通过Spring Security拦截未认证请求到授权服务器进行认证。为了简单起见，CSRF被禁用。 123456789101112131415@Configuration(proxyBeanMethods = false)@EnableWebFluxSecuritypublic class OAuth2LoginSecurityConfig { @Bean public SecurityWebFilterChain securityWebFilterChain(ServerHttpSecurity http) { http .authorizeExchange(authorize -&gt; authorize .anyExchange().authenticated() ) .oauth2Login(withDefaults()) .cors().disable(); return http.build(); }} Spring Cloud Gateway在完成OpenID Connect身份验证后，将用户信息和令牌存储在session会话中，所以添加spring-session-data-redis提供由 Redis 支持的分布式会话功能，在application.yml中添加以下配置： 12345678910spring: session: store-type: redis # 会话存储类型 redis: flush-mode: on_save # 会话刷新模式 namespace: gateway:session # 用于存储会话的键的命名空间 redis: host: localhost port: 6379 password: 123456 基于上述示例我们使用 Spring Cloud Gateway驱动身份验证，知道如何对用户进行身份验证，可以为用户获取令牌（在用户同意后），但不对通过Gateway的请求进行身份验证/授权（Spring Gateway Cloud并不是Access Token的受众目标）。这种方法背后的原因是一些服务是受保护的，而一些是公共的。即使在单个服务中，有时也只能保护几个端点而不是每个端点。这就是我将请求的身份验证/授权留给特定服务的原因。 当然从实现角度并不妨碍我们在Spring Cloud Gateway进行身份验证/授权，这只是一个选择问题。 搭建资源服务本节中我们使用Spring Boot搭建一个简单的资源服务，示例中资源服务提供两个API接口，并通过Spring Security OAuth2资源服务配置保护。 Maven依赖123456789101112131415&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;version&gt;2.6.7&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-security&lt;/artifactId&gt; &lt;version&gt;2.6.7&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-oauth2-resource-server&lt;/artifactId&gt; &lt;version&gt;2.6.7&lt;/version&gt;&lt;/dependency&gt; 配置在application.yml中添加jwk-set-uri属性： 12345678910spring: security: oauth2: resourceserver: jwt: issuer-uri: http://127.0.0.1:8080 jwk-set-uri: http://127.0.0.1:8080/oauth2/jwks server: port: 8090 创建ResourceServerConfig类来配置Spring Security安全模块，@EnableMethodSecurity注解来启用基于注解的安全性： 123456789101112131415@Configuration(proxyBeanMethods = false)@EnableWebSecurity@EnableMethodSecuritypublic class ResourceServerConfig { @Bean SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception { http.authorizeHttpRequests((authorize) -&gt; authorize .anyRequest().authenticated() ) .oauth2ResourceServer() .jwt(); return http.build(); }} 最后我们将创建用于示例中测试的API接口，使用@PreAuthorize保护接口必须由相应权限才能访问： 123456789101112131415161718192021222324@RestControllerpublic class ArticleController { List&lt;String&gt; article = new ArrayList&lt;String&gt;() {{ add(\"article1\"); add(\"article2\"); }}; @PreAuthorize(\"hasAuthority('SCOPE_read')\") @GetMapping(\"/resource/article/read\") public Map&lt;String, Object&gt; read(@AuthenticationPrincipal Jwt jwt) { Map&lt;String, Object&gt; result = new HashMap&lt;&gt;(2); result.put(\"principal\", jwt.getClaims()); result.put(\"article\", article); return result; } @PreAuthorize(\"hasAuthority('SCOPE_write')\") @GetMapping(\"/resource/article/write\") public String write(@RequestParam String name) { article.add(name); return \"success\"; }} Spring 自动在所需scope名称前添加“SCOPE_”，这样实际所需的scope是“read”而不是“SCOPE_read”。 测试我们的应用程序在我们启动完成服务后，我们在浏览器中访问http://127.0.0.1:8070/resource/article/read ,我们将重定向到授权服务登录页，如图所示： 在我们输入用户名密码（admin/password）后，将获取到请求响应信息： admin用户所属角色是ROLE_ADMIN，所以我们尝试请求http://127.0.0.1:8070/resource/article/write?name=article3 注销登录后，我们同样访问http://127.0.0.1:8070/resource/article/read ，不过这次使用Github登录，响应信息如图所示： 可以看到响应信息中用户已经切换为你的Github用户名。 Github登录的用户默认赋予角色为ROLE_OPERATION,而ROLE_OPERATION是没有http://127.0.0.1:8070/resource/article/write?name=article3 访问权限，我们来尝试测试下: 结果我们请求被拒绝，403状态码提示我们没有访问权限。 结论本文中您了解到如何使用Spring Cloud Gateway结合OAuth2保护微服务。在示例中浏览器cookie仅存储sessionId，JWT访问令牌并没有暴露给浏览器，而是在内部服务中流转。这样我们体验到了JWT带来的优势，也同样利用cookie-session弥补了JWT的不足，例如当我们需要实现强制用户登出功能。 与往常一样，本文中使用的源代码可在 GitHub 上获得。","link":"/2022/08/13/spring-gateway-oauth2/"},{"title":"将JWT与Spring Security OAuth2结合使用","text":"将JWT与Spring Security OAuth2结合使用概述OAuth 2.0 是行业标准的授权协议。OAuth 2.0 专注于客户端开发人员的简单性，同时为 Web 应用程序、桌面应用程序、移动电话和客厅设备提供特定的授权流程。 OAuth 授权服务器负责对用户进行身份验证并发布包含用户数据和适当访问策略的访问令牌。 下面我们将使用Spring Authorization Server构建一个简单的授权服务器。 OAuth2授权服务器实现让我们从OAuth2授权服务器配置实现开始。 maven依赖1234567891011 &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-security&lt;/artifactId&gt; &lt;version&gt;2.6.7&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.security&lt;/groupId&gt; &lt;artifactId&gt;spring-security-oauth2-authorization-server&lt;/artifactId&gt; &lt;version&gt;0.3.1&lt;/version&gt;&lt;/dependency&gt; 配置首先让我们通过application.yml配置数据库连接信息. 12345678910spring: application: name: auth-server datasource: druid: db-type: mysql driver-class-name: com.mysql.cj.jdbc.Driver url: jdbc:mysql://localhost:3306/integrated_oauth?createDatabaseIfNotExist=true&amp;useUnicode=true&amp;characterEncoding=UTF-8&amp;useSSL=false&amp;serverTimezone=Asia/Shanghai&amp;allowPublicKeyRetrieval=true username: &lt;&lt;username&gt;&gt; # 修改用户名 password: &lt;&lt;password&gt;&gt; # 修改密码 之后我们创建一个AuthorizationServerConfig配置类，在此类中我们将创建OAuth2授权服务器所需特定的Bean。第一个将是客户端服务存储库，我们使用RegisteredClient构建器类型创建一个客户端，并将它持久化到数据库中。 1234567891011121314151617181920212223242526272829303132@Bean public RegisteredClientRepository registeredClientRepository(JdbcTemplate jdbcTemplate) { RegisteredClient registeredClient = RegisteredClient.withId(UUID.randomUUID().toString()) .clientId(\"relive-client\") .clientSecret(\"{noop}relive-client\") .clientAuthenticationMethods(s -&gt; { s.add(ClientAuthenticationMethod.CLIENT_SECRET_POST); s.add(ClientAuthenticationMethod.CLIENT_SECRET_BASIC); }) .authorizationGrantType(AuthorizationGrantType.AUTHORIZATION_CODE) .authorizationGrantType(AuthorizationGrantType.REFRESH_TOKEN) .authorizationGrantType(AuthorizationGrantType.CLIENT_CREDENTIALS) .authorizationGrantType(AuthorizationGrantType.PASSWORD) .redirectUri(\"http://127.0.0.1:8070/login/oauth2/code/messaging-client-authorization-code\") .scope(\"message.read\") .clientSettings(ClientSettings.builder() .requireAuthorizationConsent(true) .requireProofKey(false) .build()) .tokenSettings(TokenSettings.builder() .idTokenSignatureAlgorithm(SignatureAlgorithm.RS256) .accessTokenTimeToLive(Duration.ofSeconds(30 * 60)) .refreshTokenTimeToLive(Duration.ofSeconds(60 * 60)) .reuseRefreshTokens(true) .build()) .build(); JdbcRegisteredClientRepository registeredClientRepository = new JdbcRegisteredClientRepository(jdbcTemplate); registeredClientRepository.save(registeredClient); return registeredClientRepository; } 我们配置的属性是： id–Registeredclient唯一标识 clentId–客户端标识符 clientSecret–客户端秘密 clientAuthenticationMethods–客户端可能使用的身份验证方法。支持的值为client_secret_basic、client_secret_post、private_key_jwt、client_secret_jwt和none authorizationGrantTypes–客户端可以使用的授权类型。支持的值为authorization_code、client_credentials和refresh_token redirectUris–客户端已注册重定向 URI scopes–允许客户端请求的范围。 clientSettings–客户端的自定义设置 tokenSettings–发布给客户端的 OAuth2 令牌的自定义设置 接下来让我们配置存储新授权和查询现有授权的中心组件OAuth2AuthorizationService。 1234@Bean public OAuth2AuthorizationService authorizationService(JdbcTemplate jdbcTemplate, RegisteredClientRepository registeredClientRepository) { return new JdbcOAuth2AuthorizationService(jdbcTemplate, registeredClientRepository); } 针对OAuth2 授权请求的授权“同意”，Spring提供了OAuth2AuthorizationConsentService存储新授权同意和查询现有授权同意的组件。 1234@Bean public OAuth2AuthorizationConsentService authorizationConsentService(JdbcTemplate jdbcTemplate, RegisteredClientRepository registeredClientRepository) { return new JdbcOAuth2AuthorizationConsentService(jdbcTemplate, registeredClientRepository); } 接下来让我们创建一个bean，配置OAuth2授权服务其他默认配置，并以用来对与未认证的授权请求，将该请求重定向到登录页面。 1234567@Bean @Order(Ordered.HIGHEST_PRECEDENCE) public SecurityFilterChain authorizationServerSecurityFilterChain(HttpSecurity http) throws Exception { OAuth2AuthorizationServerConfiguration.applyDefaultSecurity(http); return http.exceptionHandling(exceptions -&gt; exceptions. authenticationEntryPoint(new LoginUrlAuthenticationEntryPoint(\"/login\"))).build(); } 每个授权服务器都需要用于令牌的签名密钥，让我们生成一个RSA密钥： 1234567891011121314151617final class KeyGeneratorUtils { private KeyGeneratorUtils() { } static KeyPair generateRsaKey() { KeyPair keyPair; try { KeyPairGenerator keyPairGenerator = KeyPairGenerator.getInstance(\"RSA\"); keyPairGenerator.initialize(2048); keyPair = keyPairGenerator.generateKeyPair(); } catch (Exception ex) { throw new IllegalStateException(ex); } return keyPair; }} 123456789101112131415public final class Jwks { private Jwks() { } public static RSAKey generateRsa() { KeyPair keyPair = KeyGeneratorUtils.generateRsaKey(); RSAPublicKey publicKey = (RSAPublicKey) keyPair.getPublic(); RSAPrivateKey privateKey = (RSAPrivateKey) keyPair.getPrivate(); return new RSAKey.Builder(publicKey) .privateKey(privateKey) .keyID(UUID.randomUUID().toString()) .build(); }} 123456@Bean public JWKSource&lt;SecurityContext&gt; jwkSource() { RSAKey rsaKey = Jwks.generateRsa(); JWKSet jwkSet = new JWKSet(rsaKey); return (jwkSelector, securityContext) -&gt; jwkSelector.select(jwkSet); } 处理完令牌的签名密钥，授权服务器还需要一个颁发者URL，我们可以通过ProviderSettings创建： 123456@Beanpublic ProviderSettings providerSettings() { return ProviderSettings.builder() .issuer(\"http://127.0.0.1:8080\") .build();} 最后我们将启用Spring Security安全配置类，以保护我们的服务。 1234567891011121314151617@EnableWebSecurity@Configurationpublic class DefaultSecurityConfig { @Bean SecurityFilterChain defaultSecurityFilterChain(HttpSecurity http) throws Exception { http .authorizeRequests(authorizeRequests -&gt; authorizeRequests.anyRequest().authenticated() ) .formLogin(withDefaults()) return http.build(); } //...} 这里authorizeRequests.anyRequest().authenticated()让所有请求都需要认证，并提供基于Form表单的身份认证。 我们还需要定义测试使用的用户信息，以下创建一个基于内存的用户信息存储库。 123456789@BeanUserDetailsService users() { UserDetails user = User.withDefaultPasswordEncoder() .username(\"admin\") .password(\"password\") .roles(\"USER\") .build(); return new InMemoryUserDetailsManager(user);} 资源服务器实现现在我们将创建一个资源服务器，服务中的API接口只允许通过OAuth2授权服务器身份验证的请求。 maven依赖123456789101112131415&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;version&gt;2.6.7&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-security&lt;/artifactId&gt; &lt;version&gt;2.6.7&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-oauth2-resource-server&lt;/artifactId&gt; &lt;version&gt;2.6.7&lt;/version&gt;&lt;/dependency&gt; 配置首先让我们通过application.yml配置服务端口。 12server: port: 8090 接下来，进行OAuth2安全配置，我们需要使用之前授权服务器在ProviderSettings中设置的issuerUri。 123456spring: security: oauth2: resourceserver: jwt: issuer-uri: http://127.0.0.1:8080 资源服务器将使用此Uri进一步进行自我配置，发现授权服务器的公钥，并传入用于验证JWT的JwtDecoder。此过程的结果是授权服务器必须启动并接收请求才能使资源服务器成功启动。 如果资源服务器必须能够独立于授权服务器启动，那么可以提供jwk-set-uri。这将是我们进一步在OAuth2安全配置中添加属性： 12345678spring: security: oauth2: resourceserver: jwt: issuer-uri: http://127.0.0.1:8080 jwk-set-uri: http://127.0.0.1:8080/oauth2/jwks 现在我们可以设置Spring Security安全配置，对服务资源的每个请求都应该被授权并具有适当的权限： 1234567891011121314151617@EnableWebSecuritypublic class ResourceServerConfig { @Bean SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception { http.requestMatchers() .antMatchers(\"/resource/test/**\") .and() .authorizeRequests() .mvcMatchers(\"/resource/test/**\") .access(\"hasAuthority('SCOPE_message.read')\") .and() .oauth2ResourceServer() .jwt(); return http.build(); }} 最后，我们将创建一个 REST 控制器，它将返回jwt的claims信息。 12345678@RestControllerpublic class ResourceServerTestController { @GetMapping(\"/resource/test\") public Map&lt;String, Object&gt; getArticles(@AuthenticationPrincipal Jwt jwt) { return jwt.getClaims(); }} OAuth2客户端现在我们要创建一个客户端，它首先向授权服务器请求授权获取访问令牌，在访问资源服务器对应资源。 maven依赖1234567891011121314151617181920&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;version&gt;2.6.7&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-security&lt;/artifactId&gt; &lt;version&gt;2.6.7&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-oauth2-client&lt;/artifactId&gt; &lt;version&gt;2.6.7&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webflux&lt;/artifactId&gt; &lt;version&gt;5.3.9&lt;/version&gt;&lt;/dependency&gt; 配置首先我们将要在application.yml中配置客户端的访问端口8070。 12server: port: 8070 接下来我们将定义OAuth2客户端的配置属性： 1234567891011121314151617spring: security: oauth2: client: registration: messaging-client-authorization-code: provider: client-provider client-id: relive-client client-secret: relive-client authorization-grant-type: authorization_code redirect-uri: \"http://127.0.0.1:8070/login/oauth2/code/{registrationId}\" scope: message.read client-name: messaging-client-authorization-code provider: client-provider: authorization-uri: http://127.0.0.1:8080/oauth2/authorize token-uri: http://127.0.0.1:8080/oauth2/token 现在让我们创建一个WebClient实例用于向资源服务器执行HTTP请求： 1234567@Bean WebClient webClient(OAuth2AuthorizedClientManager authorizedClientManager) { ServletOAuth2AuthorizedClientExchangeFilterFunction oauth2Client = new ServletOAuth2AuthorizedClientExchangeFilterFunction(authorizedClientManager); return WebClient.builder() .apply(oauth2Client.oauth2Configuration()) .build(); } WebClient添加了一个OAuth2授权过滤器，需要OAuth2AuthorizedClientManager作为依赖项，在此处只配置了授权码和刷新token，如有需要可以添加其他模式： 123456789101112131415@Bean OAuth2AuthorizedClientManager authorizedClientManager(ClientRegistrationRepository clientRegistrationRepository, OAuth2AuthorizedClientRepository authorizedClientRepository) { //可以扩展其他模式 OAuth2AuthorizedClientProvider authorizedClientProvider = OAuth2AuthorizedClientProviderBuilder .builder() .authorizationCode() .refreshToken() .build(); DefaultOAuth2AuthorizedClientManager authorizedClientManager = new DefaultOAuth2AuthorizedClientManager(clientRegistrationRepository, authorizedClientRepository); authorizedClientManager.setAuthorizedClientProvider(authorizedClientProvider); return authorizedClientManager; } 最后，我们将配置Spring Security安全配置： 12345678910@Bean SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception { http .authorizeRequests(authorizeRequests -&gt; //便于测试，将权限开放 authorizeRequests.anyRequest().permitAll() ) .oauth2Client(withDefaults()); return http.build(); } 这里我们将客户端API权限全部放开，但是在实际情况下，客户端服务是需要认证的，OAuth2协议本身是授权协议，并不关心认证的具体表现形式，你也可以向授权服务器一样添加简单的表单认证。 访问资源列表最后，我们创建一个控制器，我们将使用之前配置的WebClient向我们资源服务器发起HTTP请求： 12345678910111213141516@RestControllerpublic class ClientTestController { @Autowired private WebClient webClient; @GetMapping(value = \"/client/test\") public Map&lt;String, Object&gt; getArticles(@RegisteredOAuth2AuthorizedClient(\"messaging-client-authorization-code\") OAuth2AuthorizedClient authorizedClient) { return this.webClient .get() .uri(\"http://127.0.0.1:8090/resource/test\") .attributes(oauth2AuthorizedClient(authorizedClient)) .retrieve() .bodyToMono(Map.class) .block(); }} 在上面示例中，我们使用@RegisteredOAuth2AuthorizedClient注解绑定OAuth2AuthorizedClient，并以触发OAuth2授权码模式流程获取访问令牌。 结论本例主要演示在使用OAuth2进行两个服务安全通信，尤其是在复杂的互联网场景中，客户端服务和资源服务恰好由不同的平台提供，OAuth2非常善于获取用户的委托决策，很多方面他都比其他方案更简单，更安全。 与往常一样，本文中使用的源代码可在 GitHub 上获得。","link":"/2022/06/26/spring-security-oauth2-jwt/"},{"title":"SpringBoot启动完成前后执行某个方法","text":"在项目启动完成之前 实现ApplicationListener，ContextRefreshedEvent为启动事件。 1234567@Componentpublic class ApplicationListenerDemo implements ApplicationListener&lt;ContextRefreshedEvent&gt; { @Override public void onApplicationEvent(ContextRefreshedEvent contextRefreshedEvent) { System.out.println(\"applicationListener before server success\"); }} 在项目启动完成之后方式一 ：实现ApplicationRunner接口1234567@Componentpublic class ApplicationRunnerDemo implements ApplicationRunner { @Override public void run(ApplicationArguments args) throws Exception { System.out.println(\"run after server success\"); }} 方式二：实现CommandLineRunner接口123456public class CommandLineRunnerDemo implements CommandLineRunner { @Override public void run(String... args) throws Exception { System.out.println(\"commandLineRunner after server success\"); }} 原理启动类的run方法调用了callRunners方法 1234567891011121314151617181920212223242526272829303132333435363738394041public ConfigurableApplicationContext run(String... args) { StopWatch stopWatch = new StopWatch(); stopWatch.start(); ConfigurableApplicationContext context = null; Collection&lt;SpringBootExceptionReporter&gt; exceptionReporters = new ArrayList(); this.configureHeadlessProperty(); SpringApplicationRunListeners listeners = this.getRunListeners(args); listeners.starting(); Collection exceptionReporters; try { ApplicationArguments applicationArguments = new DefaultApplicationArguments(args); ConfigurableEnvironment environment = this.prepareEnvironment(listeners, applicationArguments); this.configureIgnoreBeanInfo(environment); Banner printedBanner = this.printBanner(environment); context = this.createApplicationContext(); exceptionReporters = this.getSpringFactoriesInstances(SpringBootExceptionReporter.class, new Class[]{ConfigurableApplicationContext.class}, context); this.prepareContext(context, environment, listeners, applicationArguments, printedBanner); this.refreshContext(context); this.afterRefresh(context, applicationArguments); stopWatch.stop(); if (this.logStartupInfo) { (new StartupInfoLogger(this.mainApplicationClass)).logStarted(this.getApplicationLog(), stopWatch); } listeners.started(context); //执行callRunners方法 this.callRunners(context, applicationArguments); } catch (Throwable var10) { this.handleRunFailure(context, var10, exceptionReporters, listeners); throw new IllegalStateException(var10); } try { listeners.running(context); return context; } catch (Throwable var9) { this.handleRunFailure(context, var9, exceptionReporters, (SpringApplicationRunListeners)null); throw new IllegalStateException(var9); } } callRunners方法会调用容器里所有实现了ApplicationRunner、CommandLineRunner接口的方法 12345678910111213141516171819private void callRunners(ApplicationContext context, ApplicationArguments args) { List&lt;Object&gt; runners = new ArrayList(); runners.addAll(context.getBeansOfType(ApplicationRunner.class).values()); runners.addAll(context.getBeansOfType(CommandLineRunner.class).values()); AnnotationAwareOrderComparator.sort(runners); Iterator var4 = (new LinkedHashSet(runners)).iterator(); while(var4.hasNext()) { Object runner = var4.next(); if (runner instanceof ApplicationRunner) { this.callRunner((ApplicationRunner)runner, args); } if (runner instanceof CommandLineRunner) { this.callRunner((CommandLineRunner)runner, args); } } }","link":"/2022/05/10/spring-start-event/"},{"title":"SpringBoot整合redis","text":"Redis介绍Redis是当前比较热门的NOSQL系统之一，它是一个开源的使用ANSI c语言编写的key-value存储系统（区别于MySQL的二维表格的形式存储。）。和Memcache类似，但很大程度补偿了Memcache的不足。和Memcache一样，Redis数据都是缓存在计算机内存中，不同的是，Memcache只能将数据缓存到内存中，无法自动定期写入硬盘，这就表示，一断电或重启，内存清空，数据丢失。所以Memcache的应用场景适用于缓存无需持久化的数据。而Redis不同的是它会周期性的把更新的数据写入磁盘或者把修改操作写入追加的记录文件，实现数据的持久化。 Redis的特点： Redis读取的速度是110000次/s，写的速度是81000次/s； 原子 。Redis的所有操作都是原子性的，同时Redis还支持对几个操作全并后的原子性执行。 支持多种数据结构：string（字符串）；list（列表）；hash（哈希），set（集合）；zset(有序集合) 持久化，集群部署 支持过期时间，支持事务，消息订阅 引入依赖springboot版本使用的是2.3.0 123456789&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.apache.commons&lt;/groupId&gt; &lt;artifactId&gt;commons-pool2&lt;/artifactId&gt; &lt;version&gt;2.6.1&lt;/version&gt; &lt;/dependency&gt; application.yml1234567891011121314spring: redis: host: 192.168.234.131 #Redis服务器地址 database: 0 #Redis数据库索引（默认为0） port: 6379 #Redis服务器连接端口 password: 123456 #Redis服务器连接密码（默认为空） timeout: 180000 #连接超时时间（毫秒） lettuce: pool: max-active: 20 #连接池最大连接数（使用负值表示没有限制） max-wait: 10000 #连接池最大阻塞等待时间（使用负值表示没有限制） max-idle: 5 #连接池中的最大空闲连接 min-idle: 0 #连接池中的最小空闲连接 shutdown-timeout: 100 #关闭超时时间 添加redis配置类1234567891011121314151617181920212223242526272829303132333435363738394041424344@EnableCaching@Configurationpublic class RedisConfig extends CachingConfigurerSupport { @Bean public RedisTemplate&lt;String, Object&gt; redisTemplate(RedisConnectionFactory factory) { RedisTemplate&lt;String, Object&gt; template = new RedisTemplate&lt;&gt;(); RedisSerializer&lt;String&gt; redisSerializer = new StringRedisSerializer(); Jackson2JsonRedisSerializer jackson2JsonRedisSerializer = new Jackson2JsonRedisSerializer(Object.class); ObjectMapper om = new ObjectMapper(); om.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.ANY); om.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL); jackson2JsonRedisSerializer.setObjectMapper(om); template.setConnectionFactory(factory); //key序列化方式 template.setKeySerializer(redisSerializer); //value序列化 template.setValueSerializer(jackson2JsonRedisSerializer); //value hashmap序列化 template.setHashValueSerializer(jackson2JsonRedisSerializer); return template; } @Bean public CacheManager cacheManager(RedisConnectionFactory factory) { RedisSerializer&lt;String&gt; redisSerializer = new StringRedisSerializer(); Jackson2JsonRedisSerializer jackson2JsonRedisSerializer = new Jackson2JsonRedisSerializer(Object.class); //解决查询缓存转换异常的问题 ObjectMapper om = new ObjectMapper(); om.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.ANY); om.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL); jackson2JsonRedisSerializer.setObjectMapper(om); // 配置序列化（解决乱码的问题）,过期时间600秒 RedisCacheConfiguration config = RedisCacheConfiguration.defaultCacheConfig() .entryTtl(Duration.ofSeconds(600)) .serializeKeysWith(RedisSerializationContext.SerializationPair.fromSerializer(redisSerializer)) .serializeValuesWith(RedisSerializationContext.SerializationPair.fromSerializer(jackson2JsonRedisSerializer)) .disableCachingNullValues(); RedisCacheManager cacheManager = RedisCacheManager.builder(factory) .cacheDefaults(config) .build(); return cacheManager; }} SpringBoot缓存注解@EnableCaching开启基于注解的缓存 缓存@Cacheable根据方法对其返回结果进行缓存，下次请求时，如果缓存存在，则直接读取缓存数据返回；如果缓存不存在，则执行方法，并把返回的结果存入缓存中。一般用在查询方法上。属性值如下： 属性名 解释 value 缓存名，必填，它指定了你的缓存存放在哪块命名空间 cacheNames 与 value 差不多，二选一即可 key 缓存的 key，可以为空，如果指定要按照 SpEL 表达 式编写，如果不指定，则缺省按照方法的所有参数进行组合 keyGenerator 缓存数据时key生成策略，与key属性互斥 cacheManager 指定自定义CacheManager的名称，与cacheResolver属性互斥 cacheResolver 指定自定义的CacheResolver名称 condition 缓存的条件，可以为空，表示方法结果始终被缓存。而使用 SpEL 编写，返回 true 或者 false，只有为 true 才进行缓存/清除缓存，在调用方法之前之后都能判断 unless 用于否决缓存的，不像condition，该表达式只在方法执行之后判断，此时可以拿到返回值result进行判 断。条件为true不会缓存，fasle才缓存 sync 是否同步，默认是false，如果为true，unless将不受支持 @CachePut使用该注解标志的方法，每次都会执行，并将结果存入指定的缓存中。其他方法可以直接从响应的缓存中读取缓存数据，而不需要再去查询数据库。一般用在新增和更新方法上。属性值如下： 属性名 解释 value 缓存名，必填，它指定了你的缓存存放在哪块命名空间 cacheNames 与 value 差不多，二选一即可 key 缓存的 key，可以为空，如果指定要按照 SpEL 表达式编写，如果不指定，则缺省按照方法的所有参数进行组合 keyGenerator 缓存数据时key生成策略，与key属性互斥 cacheManager 指定自定义CacheManager的名称，与cacheResolver属性互斥 cacheResolver 指定自定义的CacheResolver名称 condition 缓存的条件，可以为空，表示方法结果始终被缓存。而使用SpEL 编写，返回 true 或者 false，只有为 true 才进行缓存/清除缓存，在调用方法之前之后都能判断 unless 用于否决缓存的，不像condition，该表达式只在方法执行之后判断，此时可以拿到返回值result进行判 断。条件为true不会缓存，fasle才缓存 @CacheEvict使用该注解标志的方法，会清空指定的缓存。一般用在更新或者删除方法上，属性值如下： 属性名 解释 value 缓存名，必填，它指定了你的缓存存放在哪块命名空间 cacheNames 与 value 差不多，二选一即可 key 缓存的 key，可以为空，如果指定要按照 SpEL 表达式编写，如果不指定，则缺省按照方法的所有参数进行组合 keyGenerator 缓存数据时key生成策略，与key属性互斥 cacheManager 指定自定义CacheManager的名称，与cacheResolver属性互斥 cacheResolver 指定自定义的CacheResolver名称 condition 缓存的条件，可以为空，表示方法结果始终被缓存。而使用 SpEL 编写，返回 true 或者 false，只有为 true 才进行缓存/清除缓存，在调用方法之前之后都能判断 allEntries 是否清空所有缓存内容，缺省为 false。如果指定为 true，则方法调用后将立即清空所有缓存。注意不允许将此参数设置为true并指定一个key beforeInvocation 是否在方法执行前就清空，缺省为 false。缺省情况下，如果方法执行抛出异常，则不会清空缓存。如果指定 为 true，则在方法还没有执行的时候就清空缓存。 @Caching不同或相同类型的缓存注释的组注释，用于定制复杂的缓存规则。 属性名 解释 cacheable 默认为空，可以定义一个或多个@Cacheable put 默认为空，可以定义一个或多个@CachePut evict 默认为空，可以定义一个或多个@CacheEvict @CacheConfig用于标注在类上，可以存放该类中所有缓存的公有属性，比如设置缓存的名字。 属性名 解释 cacheNames 与 value 差不多，二选一即可 keyGenerator 缓存数据时key生成策略，与key属性互斥 cacheManager 指定自定义CacheManager的名称，如果没有设置cacheResolver，并且在类中的缓存注解未设置缓存解析器和缓存管理器，则使用该管理器而不是默认值。 cacheResolver 指定自定义CacheResolver的名称，如果在类中的缓存注解没有设置解析器和缓存管理器，则使用此解析器而不是默认值。 SpEL 名字 位置 描述 示例 methodName root object 当前被调用的方法名 #root.methodName method root object 当前被调用的方法 #root.method.name target root object 当前被调用的目标对象 #root.target targetClass root object 当前被调用的目标对象类 #root.targetClass args root object 当前被调用的方法的参数列表 #root.args[0] 表示参数列表第一个参数 caches root object 当前方法调用使用的缓存列表（如@Cacheable(value={“cache1”, “cache2”})），则有两个cache #root.caches[0].name，取缓存列表中第一个缓存名称 argument name evaluation context(上下文) 方法参数的名字. 可以直接 #参数名 ，也可以使用 #p0或#a0 的 形式，0代表参数的索引； #id、#p0,#a0 result evaluation context 方法执行后的返回值（仅当方法执行之后的判断有效，如 ‘unless’，’cache put’的表达式 ’cache evict’的属性beforeInvocation=false #result，#result.id(返回结果的属性名) 使用RestTemplate操作redis1.redisTemplate.opsForValue();//操作字符串 2.redisTemplate.opsForHash();//操作hash 3.redisTemplate.opsForList();//操作list 4.redisTemplate.opsForSet();//操作set 5.redisTemplate.opsForZSet();//操作有序set 其他操作不一一列举 测试首先我们先编写一个小Demo，我持久化层使用的是mybatis,这里代码很简单，就直接越过。 然后看一下我们service层代码，在方法上添加了@Cacheable注解 123456789101112@Servicepublic class DepartmentService { @Autowired private DepartmentMapper departmentMapper; @Cacheable(cacheNames = \"dep\",key = \"#id\") public Department getDep(Integer id){ Department byId = departmentMapper.getById(id); return byId; }} 编写测试方法，看打印的日志结果 12345@Test void contextLoads() { Department dep = departmentService.getDep(1); System.out.println(dep); } 第一次执行从数据库里查数据，日志打印出SQL语句第二次执行，日志没有打印SQL语句，说明是从redis缓存取数据而我们也可以打开Redis Desktop Manager查看，数据的确存进缓存中了","link":"/2022/05/10/springboot-integrate-redis/"},{"title":"Spring Security和OpenID Connect","text":"Spring Security和OpenID Connect概述OpenID Connect 是一个开放标准，由 OpenID 基金会于 2014 年 2 月发布。它定义了一种使用 OAuth 2.0 执行用户身份认证的互通方式。OpenID Connect 直接基于 OAuth 2.0 构建，并保持与它兼容。 当授权服务器支持 OIDC 时，它有时被称为身份提供者（Idp），因为它向客户端提供有关资源所有者的信息。而客户端映射为OpenID Connect 流程中登录依赖方（RP）。在本文中我们将授权服务称为身份提供者，客户端称为登录依赖方进行陈述。 OpenID Connect 流程看起来与 OAuth 相同。主要区别是，在授权请求中，使用了一个特定的范围openid，而在获取token中，登录依赖方（RP）同时接收到一个访问令牌和一个ID 令牌（经过签名的 JWT）。ID令牌与访问令牌不同的是，ID 令牌是发送给 RP 的，并且要被它解析。 本文您将学到： 配置授权服务支持OpenID Connect 自定义ID令牌 登录依赖方通过OAuth2UserService实现权限映射 先决条件： java 8+ mysql 使用Spring Authorization Server搭建身份提供服务(IdP)本节中我们将使用Spring Authorization Server搭建身份提供服务，并通过OAuth2TokenCustomizer实现自定义ID Token。 maven 依赖项1234567891011121314151617&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-security&lt;/artifactId&gt; &lt;version&gt;2.6.7&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.security&lt;/groupId&gt; &lt;artifactId&gt;spring-security-oauth2-authorization-server&lt;/artifactId&gt; &lt;version&gt;0.3.1&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;version&gt;2.6.7&lt;/version&gt;&lt;/dependency&gt; 配置首先我们配置身份提供服务端口8080: 12server: port: 8080 接下来我们创建AuthorizationServerConfig配置类，在此类中我们配置OAuth2及OICD相关Bean。我们首先注册一个客户端： 1234567891011121314151617181920212223242526272829@Beanpublic RegisteredClientRepository registeredClientRepository() { RegisteredClient registeredClient = RegisteredClient.withId(UUID.randomUUID().toString()) .clientId(\"relive-client\") .clientSecret(\"{noop}relive-client\") .clientAuthenticationMethods(s -&gt; { s.add(ClientAuthenticationMethod.CLIENT_SECRET_POST); s.add(ClientAuthenticationMethod.CLIENT_SECRET_BASIC); }) .authorizationGrantType(AuthorizationGrantType.AUTHORIZATION_CODE) .authorizationGrantType(AuthorizationGrantType.REFRESH_TOKEN) .redirectUri(\"http://127.0.0.1:8070/login/oauth2/code/messaging-client-oidc\") .scope(OidcScopes.OPENID) .scope(OidcScopes.PROFILE) .scope(OidcScopes.EMAIL) .clientSettings(ClientSettings.builder() .requireAuthorizationConsent(true) .requireProofKey(false) .build()) .tokenSettings(TokenSettings.builder() .accessTokenFormat(OAuth2TokenFormat.SELF_CONTAINED) .idTokenSignatureAlgorithm(SignatureAlgorithm.RS256) .accessTokenTimeToLive(Duration.ofSeconds(30 * 60)) .refreshTokenTimeToLive(Duration.ofSeconds(60 * 60)) .reuseRefreshTokens(true) .build()) .build(); return new InMemoryRegisteredClientRepository(registeredClient);} 我们正在配置的属性是： clientId – Spring Security将使用它来识别哪个客户端正在尝试访问资源 clientSecret——客户端和服务器都知道的一个秘密，它提供了两者之间的信任 客户端验证方式——在我们的例子中，我们将支持basic和post身份验证方式 授权类型——允许客户端生成授权码和刷新令牌 重定向 URI – 客户端将在基于重定向的流程中使用它 scope——此参数定义客户端可能拥有的权限。在我们的例子中，我们将拥有所需的OidcScopes.OPENID和用来获取额外的身份信息OidcScopes.PROFILE，OidcScopes.EMAIL。 OpenID Connect 使用一个特殊的权限范围值 openid 来控制对 UserInfo 端点的访问。 OpenID Connect 定义了一组标准化的 OAuth 权限范围，对应于用户属性的子集profile、email、 phone、address，参见表格： 权限范围 声明 openid sub profile Name、family_name、given_name、middle_name、nickname、preferred_username、profile、 picture、website、gender、birthdate、zoneinfo、locale、updated_at email email、email_verified address address,是一个 JSON 对象、包含 formatted、street_address、locality、region、postal_code、country phone phone_number、phone_number_verified 让我们根据上述规范定义OidcUserInfoService，用于扩展/userinfo用户信息端点响应： 12345678910111213141516171819202122232425262728293031323334353637public class OidcUserInfoService { public OidcUserInfo loadUser(String name, Set&lt;String&gt; scopes) { OidcUserInfo.Builder builder = OidcUserInfo.builder().subject(name); if (!CollectionUtils.isEmpty(scopes)) { if (scopes.contains(OidcScopes.PROFILE)) { builder.name(\"First Last\") .givenName(\"First\") .familyName(\"Last\") .middleName(\"Middle\") .nickname(\"User\") .preferredUsername(name) .profile(\"http://127.0.0.1:8080/\" + name) .picture(\"http://127.0.0.1:8080/\" + name + \".jpg\") .website(\"http://127.0.0.1:8080/\") .gender(\"female\") .birthdate(\"2022-05-24\") .zoneinfo(\"China/Beijing\") .locale(\"zh-cn\") .updatedAt(LocalDateTime.now().format(DateTimeFormatter.ISO_LOCAL_DATE)); } if (scopes.contains(OidcScopes.EMAIL)) { builder.email(name + \"@163.com\").emailVerified(true); } if (scopes.contains(OidcScopes.ADDRESS)) { JSONObject address = new JSONObject(); address.put(\"address\", Collections.singletonMap(\"formatted\", \"Champ de Mars\\n5 Av. Anatole France\\n75007 Paris\\nFrance\")); builder.address(address.toJSONString()); } if (scopes.contains(OidcScopes.PHONE)) { builder.phoneNumber(\"13728903134\").phoneNumberVerified(\"false\"); } } return builder.build(); }} 接下来，我们将配置一个 bean 以应用默认 OAuth 安全性。使用上述OidcUserInfoService配置OIDC中UserInfoMapper；oauth2ResourceServer()配置资源服务器使用JWT验证，用来保护Spring Security 提供的/userinfo端点；对于未认证请求我们会将它重定向到/login 登录页： 注意：有时“授权服务器”和“资源服务器”是同一台服务器。 12345678910111213141516171819202122232425262728293031@Bean@Order(Ordered.HIGHEST_PRECEDENCE)public SecurityFilterChain authorizationServerSecurityFilterChain(HttpSecurity http) throws Exception { OAuth2AuthorizationServerConfigurer&lt;HttpSecurity&gt; authorizationServerConfigurer = new OAuth2AuthorizationServerConfigurer&lt;&gt;(); //自定义用户映射器 Function&lt;OidcUserInfoAuthenticationContext, OidcUserInfo&gt; userInfoMapper = (context) -&gt; { OidcUserInfoAuthenticationToken authentication = context.getAuthentication(); JwtAuthenticationToken principal = (JwtAuthenticationToken) authentication.getPrincipal(); return userInfoService.loadUser(principal.getName(), context.getAccessToken().getScopes()); }; authorizationServerConfigurer.oidc((oidc) -&gt; { oidc.userInfoEndpoint((userInfo) -&gt; userInfo.userInfoMapper(userInfoMapper)); }); RequestMatcher endpointsMatcher = authorizationServerConfigurer.getEndpointsMatcher(); return http.requestMatcher(endpointsMatcher).authorizeRequests((authorizeRequests) -&gt; { ((ExpressionUrlAuthorizationConfigurer.AuthorizedUrl) authorizeRequests.anyRequest()).authenticated(); }).csrf((csrf) -&gt; { csrf.ignoringRequestMatchers(new RequestMatcher[]{endpointsMatcher}); }).apply(authorizationServerConfigurer) .and() .oauth2ResourceServer(OAuth2ResourceServerConfigurer::jwt) .exceptionHandling(exceptions -&gt; exceptions. authenticationEntryPoint(new LoginUrlAuthenticationEntryPoint(\"/login\"))) .apply(authorizationServerConfigurer) .and() .build();} 每个授权服务器都需要其用于令牌的签名密钥，让我们生成一个 2048 字节的 RSA 密钥： 12345678910111213141516171819202122232425262728293031323334353637383940@Beanpublic JWKSource&lt;SecurityContext&gt; jwkSource() { RSAKey rsaKey = Jwks.generateRsa(); JWKSet jwkSet = new JWKSet(rsaKey); return (jwkSelector, securityContext) -&gt; jwkSelector.select(jwkSet);}static class Jwks { private Jwks() { } public static RSAKey generateRsa() { KeyPair keyPair = KeyGeneratorUtils.generateRsaKey(); RSAPublicKey publicKey = (RSAPublicKey) keyPair.getPublic(); RSAPrivateKey privateKey = (RSAPrivateKey) keyPair.getPrivate(); return new RSAKey.Builder(publicKey) .privateKey(privateKey) .keyID(UUID.randomUUID().toString()) .build(); }}static class KeyGeneratorUtils { private KeyGeneratorUtils() { } static KeyPair generateRsaKey() { KeyPair keyPair; try { KeyPairGenerator keyPairGenerator = KeyPairGenerator.getInstance(\"RSA\"); keyPairGenerator.initialize(2048); keyPair = keyPairGenerator.generateKeyPair(); } catch (Exception ex) { throw new IllegalStateException(ex); } return keyPair; }} 然后我们将使用带有@EnableWebSecurity注释的配置类启用 Spring Web 安全模块： 1234567891011121314151617@Configuration(proxyBeanMethods = false)@EnableWebSecuritypublic class DefaultSecurityConfig { @Bean SecurityFilterChain defaultSecurityFilterChain(HttpSecurity http) throws Exception { http .authorizeRequests(authorizeRequests -&gt; authorizeRequests.anyRequest().authenticated() ) .formLogin(withDefaults()); return http.build(); } //...} 这里我们使用Form表单认证方式，所以我们还需要为登录认证提供用户名和密码： 123456789@BeanUserDetailsService users() { UserDetails user = User.withDefaultPasswordEncoder() .username(\"admin\") .password(\"password\") .roles(\"ADMIN\") .build(); return new InMemoryUserDetailsManager(user);} 至此，我们服务配置完成，但是用于给客户端传递权限信息，我们将更改ID Token claim，添加用户角色属性： 123456789101112131415@Configuration(proxyBeanMethods = false)public class IdTokenCustomizerConfig { @Bean public OAuth2TokenCustomizer&lt;JwtEncodingContext&gt; tokenCustomizer() { return (context) -&gt; { if (OidcParameterNames.ID_TOKEN.equals(context.getTokenType().getValue())) { context.getClaims().claims(claims -&gt; claims.put(\"role\", context.getPrincipal().getAuthorities() .stream().map(GrantedAuthority::getAuthority) .collect(Collectors.toSet()))); } }; }} 登录依赖方服务（RP）实现本节中我们将使用Spring Security搭建登录依赖方服务，并设计相关数据库表结构表达关联身份提供方服务与登录依赖方服务权限关系，通过OAuth2UserService实现权限映射。 本节中部分代码涉及JPA相关知识，如果您并不了解也没有关系，您可以通过Mybatis进行替换。 maven 依赖项1234567891011121314151617181920212223242526272829303132333435&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;version&gt;2.6.7&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-oauth2-client&lt;/artifactId&gt; &lt;version&gt;2.6.7&lt;/version&gt; &lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-jdbc&lt;/artifactId&gt; &lt;version&gt;2.6.7&lt;/version&gt; &lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-jpa&lt;/artifactId&gt; &lt;version&gt;2.6.7&lt;/version&gt; &lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt; &lt;version&gt;2.6.7&lt;/version&gt; &lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;8.0.21&lt;/version&gt; &lt;/dependency&gt; 相关数据库表结构这是我们本文中RP服务使用的相关数据库表，涉及相关创建表及初始化数据的SQL语句可以从这里获取。 配置首先我们通过application.yml文件中配置服务端口和数据库连接信息： 123456789101112131415server: port: 8070 servlet: session: cookie: name: CLIENT-SESSIONspring: datasource: druid: db-type: mysql driver-class-name: com.mysql.cj.jdbc.Driver url: jdbc:mysql://localhost:3306/oidc_login?createDatabaseIfNotExist=true&amp;useUnicode=true&amp;characterEncoding=UTF-8&amp;useSSL=false&amp;serverTimezone=Asia/Shanghai&amp;allowPublicKeyRetrieval=true username: &lt;&lt;root&gt;&gt; # 修改用户名 password: &lt;&lt;password&gt;&gt; # 修改密码 接下来我们将启用Spring Security安全配置。使用Form认证方式；并使用oauth2Login()定义OAuth2登录默认配置： 12345678910111213@BeanSecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception { http.authorizeHttpRequests() .anyRequest() .authenticated() .and() .formLogin(from -&gt; { from.defaultSuccessUrl(\"/home\"); }) .oauth2Login(Customizer.withDefaults()) .csrf().disable(); return http.build();} 下面我们将配置OAuth2客户端基于MySql数据库的存储方式，你也可以从Spring Security 持久化OAuth2客户端了解详细信息。 123456789101112131415161718192021222324252627282930313233343536/** * 定义JDBC 客户端注册存储库 * * @param jdbcTemplate * @return */@Beanpublic ClientRegistrationRepository clientRegistrationRepository(JdbcTemplate jdbcTemplate) { return new JdbcClientRegistrationRepository(jdbcTemplate);}/** * 负责{@link org.springframework.security.oauth2.client.OAuth2AuthorizedClient}在 Web 请求之间进行持久化 * * @param jdbcTemplate * @param clientRegistrationRepository * @return */@Beanpublic OAuth2AuthorizedClientService authorizedClientService( JdbcTemplate jdbcTemplate, ClientRegistrationRepository clientRegistrationRepository) { return new JdbcOAuth2AuthorizedClientService(jdbcTemplate, clientRegistrationRepository);}/** * OAuth2AuthorizedClientRepository 是一个容器类，用于在请求之间保存和持久化授权客户端 * * @param authorizedClientService * @return */@Beanpublic OAuth2AuthorizedClientRepository authorizedClientRepository( OAuth2AuthorizedClientService authorizedClientService) { return new AuthenticatedPrincipalOAuth2AuthorizedClientRepository(authorizedClientService);} 我们不在使用基于内存的用户名密码，在初始化数据库时我们已经将用户名密码添加到user表中，所以我们需要实现UserDetailsService接口用于Form认证时获取用户信息： 1234567891011121314151617181920@RequiredArgsConstructorpublic class JdbcUserDetailsService implements UserDetailsService { private final UserRepository userRepository; @Override public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException { com.relive.entity.User user = userRepository.findUserByUsername(username); if (ObjectUtils.isEmpty(user)) { throw new UsernameNotFoundException(\"user is not found\"); } if (CollectionUtils.isEmpty(user.getRoleList())) { throw new UsernameNotFoundException(\"role is not found\"); } Set&lt;SimpleGrantedAuthority&gt; authorities = user.getRoleList().stream().map(Role::getRoleCode) .map(SimpleGrantedAuthority::new).collect(Collectors.toSet()); return new User(user.getUsername(), user.getPassword(), authorities); }} 这里UserRepository继承了JpaRepository，提供user表的CRUD，详细代码可以在文末链接中获取。 现在我们将要解决如何将IdP服务用户角色映射为RP服务已有的角色，在前面文章中曾使用GrantedAuthoritiesMapper映射角色。在本文中我们将使用OAuth2UserService添加角色映射策略，它与GrantedAuthoritiesMapper相比更加灵活: 12345678910111213141516171819202122public class OidcRoleMappingUserService implements OAuth2UserService&lt;OidcUserRequest, OidcUser&gt; { private OidcUserService oidcUserService; private final OAuth2ClientRoleRepository oAuth2ClientRoleRepository; //... @Override public OidcUser loadUser(OidcUserRequest userRequest) throws OAuth2AuthenticationException { OidcUser oidcUser = oidcUserService.loadUser(userRequest); OidcIdToken idToken = userRequest.getIdToken(); List&lt;String&gt; role = idToken.getClaimAsStringList(\"role\"); Set&lt;SimpleGrantedAuthority&gt; mappedAuthorities = role.stream() .map(r -&gt; oAuth2ClientRoleRepository.findByClientRegistrationIdAndRoleCode(userRequest.getClientRegistration().getRegistrationId(), r)) .map(OAuth2ClientRole::getRole).map(Role::getRoleCode).map(SimpleGrantedAuthority::new) .collect(Collectors.toSet()); oidcUser = new DefaultOidcUser(mappedAuthorities, oidcUser.getIdToken(), oidcUser.getUserInfo()); return oidcUser; }} 最后我们将创建HomeController，通过控制页面中展示内容使测试效果视觉上更加显著，我们将根据角色展示不同信息，使用thymeleaf模版引擎渲染。 123456789101112131415161718@Controllerpublic class HomeController { private static Map&lt;String, List&lt;String&gt;&gt; articles = new HashMap&lt;&gt;(); static { articles.put(\"ROLE_OPERATION\", Arrays.asList(\"Java\")); articles.put(\"ROLE_SYSTEM\", Arrays.asList(\"Java\", \"Python\", \"C++\")); } @GetMapping(\"/home\") public String home(Authentication authentication, Model model) { String authority = authentication.getAuthorities().iterator().next().getAuthority(); model.addAttribute(\"articles\", articles.get(authority)); return \"home\"; }} 完成配置后，我们可以访问 http://127.0.0.1:8070/login 进行测试。 结论在本文中分享了Spring Security对于OpenID Connect的支持。与往常一样，本文中使用的源代码可在 GitHub 上获得。","link":"/2022/08/01/springn-security-oidc/"}],"tags":[{"name":"spring security","slug":"spring-security","link":"/tags/spring-security/"},{"name":"OAuth2","slug":"OAuth2","link":"/tags/OAuth2/"},{"name":"ssh","slug":"ssh","link":"/tags/ssh/"},{"name":"mybatis","slug":"mybatis","link":"/tags/mybatis/"},{"name":"spring cloud","slug":"spring-cloud","link":"/tags/spring-cloud/"},{"name":"spring mvc","slug":"spring-mvc","link":"/tags/spring-mvc/"},{"name":"spring boot","slug":"spring-boot","link":"/tags/spring-boot/"},{"name":"JWT","slug":"JWT","link":"/tags/JWT/"},{"name":"redis","slug":"redis","link":"/tags/redis/"}],"categories":[{"name":"SpringSecurity","slug":"SpringSecurity","link":"/categories/SpringSecurity/"},{"name":"设计模式","slug":"设计模式","link":"/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"java","slug":"java","link":"/categories/java/"},{"name":"Mybatis","slug":"Mybatis","link":"/categories/Mybatis/"},{"name":"weekly","slug":"weekly","link":"/categories/weekly/"},{"name":"SpringCloud","slug":"SpringCloud","link":"/categories/SpringCloud/"},{"name":"SpringBoot","slug":"SpringBoot","link":"/categories/SpringBoot/"}]}