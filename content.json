{"pages":[{"title":"weekly","text":"","link":"/weekly/index.html"}],"posts":[{"title":"设计模式-工厂方法模式","text":"工厂方法模式定义工厂方法模式使用的频率非常高，在日常开发中经常会使用，其定义为： 定义一个用于创建对象的接口，让子类决定实例化哪一个类。工厂方法使一个类的实例化延迟到其子类。 通用类图如下： 工厂方法模式中，抽象产品类定义产品的共性；Factory为抽象创建类，也就是抽象工厂。代码如下： 抽象产品类代码： 123456789public abstract class Product { //产品类的公共方法 public void method1(){ //doSomething } public abstract void method2();} 具体产品类可以有多个，都继承与抽象产品类，代码如下： 12345678910111213public class ConcreteProduct1 extends Product{ @Override public void method2() { System.out.println(\"具体产品类1\"); }}public class ConcreteProduct2 extends Product{ @Override public void method2() { System.out.println(\"具体产品类2\"); }} 抽象工厂类负责定义产品对象产生，代码如下： 1234public interface ProductFactory { //创建一个产品类对象，参数可以自行设置 &lt;T extends Product&gt; T createProduct(Class&lt;T&gt; clazz);} 具体如何产生一个产品的对象，由具体的工厂类实现，代码如下： 123456789101112public class ConcreteProductFactory implements ProductFactory { @Override public &lt;T extends Product&gt; T createProduct(Class&lt;T&gt; clazz) { Product product = null; try { product = (Product) Class.forName(clazz.getName()).newInstance(); } catch (Exception e) { //异常处理 } return (T) product; }} 工厂方法模式优点 良好的封装性，代码结构清晰。对于客户端隐藏创建对象的复杂过程，降低模块间的耦合。 扩展性高。在增加产品类的情况下，只要修改具体的工厂类或扩展一个工厂类。 屏蔽产品类。产品类的实现如何变化，客户端都不需要关心，他只需要关心产品的接口，因为产品类的实例化由工厂类负责。 工厂方法模式是典型的解耦框架。高层模块只需要知道产品的抽象类，其他实现类都不关心，符合迪米特法则。只依赖产品类的抽象，符合依赖倒置原则。使用产品子类替换产品父类，也符合里氏替换原则。 使用场景工厂方法模式是new一个对象的替代品，在需要灵活的，可扩展的框架时，可以考虑采用工厂方法模式。例如使用JDBC数据库连接，数据库从MySQL切换到Oracle，需要改动的地方就是切换下驱动名称（前提SQL是标准语句）。 工厂方法模式的扩展简单工厂模式在工厂方法模式中，我们考虑一个模块只需要一个工厂类，根据这一需求，稍微改动下，将抽象工厂类去掉，类图如下： 我们去掉Factory抽象类，并把创建createProduct方法设置为静态类型，变更代码如下： 123456789101112public class ConcreteProductFactory { @Override public &lt;T extends Product&gt; T createProduct(Class&lt;T&gt; clazz) { Product product = null; try { product = (Product) Class.forName(clazz.getName()).newInstance(); } catch (Exception e) { //异常处理 } return (T) product; }} 简单工厂模式是工厂模式的弱化，在实际开发中，采用此模式还是比较多的，但是其缺点是工厂类的扩展比较困难，不符合开闭原则。 多工厂类当我们做一个复杂项目时，如果遇到一个对象初始化很耗费精力的情况，那么将所有产品类放到一个工厂方法中会使结构不清晰，例如产品类有5个具体实现，那么此时工厂方法可能会变得巨大无比。 考虑需要结构清晰，我们就为每个产品类创造一个工厂类，由客户端决定与哪个工厂方法关联。 多工厂模式的抽象工厂类代码如下： 1234public interface MultiProductFactory { Product createProduct();} 此时抽象方法不需要传递参数，因为每个具体工厂职责已经很明确了，只需要负责创建自己负责的产品类对象。 产品类1工厂类实现： 123456public class Concrete1MultiProductFactory implements MultiProductFactory{ @Override public Product createProduct() { return new ConcreteProduct1(); }} 产品类2工程类实现： 123456public class Concrete2MultiProductFactory implements MultiProductFactory { @Override public Product createProduct() { return new ConcreteProduct2(); }} 此种模式就是创建类职责清晰，但是给扩展性和维护性带来了一定的影响。如果扩展一个产品类，就需要建立相应的工厂类，这样增加了扩展的难度。因为工厂类和产品类数量相同，维护时需要考虑两个对象之间的关系。当然在采用多工厂时，可以增加一个协调类，避免客户端与各个子工厂交流，协调类的作用封装子工厂类，对外提供统一的访问接口。 延迟初始化一个对象消费完毕后，并不立刻释放，工厂类保持其初始状态，等待再次被调用。延迟初始化是工厂方法模式的一个扩展应用。 工厂类负责对象的创建工作，并通过HashMap产生一个缓存，对需要再次被调用的对象保留，参考代码如下： 123456789101112131415161718public class LazyProductFactory { private static final Map&lt;String, Product&gt; map = new HashMap&lt;&gt;(); public static synchronized Product createProduct(String type) { Product product; if (map.containsKey(type)) { product = map.get(type); } else { if (\"product1\".equals(type)) { product = new ConcreteProduct1(); } else { product = new ConcreteProduct2(); } map.put(type, product); } return product; }} 实现比较简单，通过定义一个Map容器，缓存所有产生的对象，再次调用时如果Map中已经包含则直接返回，否则根据需要产生一个对象并存Map中。 结论与往常一样，本文中使用的源代码可在 GitHub 上获得。","link":"/2022/05/15/factory-pattern/"},{"title":"使用Java连接SSH","text":"简介SSH 为建立在应用层基础上的安全协议。SSH 是较可靠，专为远程登录会话和其他网络服务提供安全性的协议。 JschJSch 是 SSH2的纯 Java 实现。JSch 允许你连接到一个 sshd 服务器并使用端口转发、X11 转发、文件传输等，你可以将它的功能集成到你自己的 Java 程序中。 首先，让我们将JSch Maven 依赖添加到我们的pom.xml文件中： 12345&lt;dependency&gt; &lt;groupId&gt;com.jcraft&lt;/groupId&gt; &lt;artifactId&gt;jsch&lt;/artifactId&gt; &lt;version&gt;0.1.55&lt;/version&gt;&lt;/dependency&gt; 执行要使用Jsch连接ssh，需要提供用户名，密码，主机，端口，以下是简单代码实例： 123456789101112131415161718192021222324252627282930313233343536373839public static void execCommand(String username, String password, String host, Integer port, String command) throws JSchException, InterruptedException { Session session = null; ChannelExec channel = null; try { session = new JSch().getSession(username, host, port); session.setPassword(password); session.setConfig(\"StrictHostKeyChecking\", \"no\"); session.connect(); channel = (ChannelExec) session.openChannel(\"exec\"); channel.setCommand(command); ByteArrayOutputStream responseStream = new ByteArrayOutputStream(); channel.setOutputStream(responseStream); ByteArrayOutputStream errorResponseStream = new ByteArrayOutputStream(); channel.setErrStream(errorResponseStream); channel.connect(); while (channel.isConnected()) { Thread.sleep(100); } String responseString = new String(responseStream.toByteArray(), StandardCharsets.UTF_8); if (!responseString.isEmpty()) { log.info(responseString); } String errorResponseString = new String(errorResponseStream.toByteArray(), StandardCharsets.UTF_8); if (!errorResponseString.isEmpty()) { log.warn(errorResponseString); } } finally { if (session != null) { session.disconnect(); } if (channel != null) { channel.disconnect(); } } } 上述代码中我们首先建立SSH会话，通过会话建立执行通道，执行我们提供的shell命令，并将响应信息和错误响应信息输出到控制台。 如何使用 JSch 提供的不同配置参数： StrictHostKeyChecking - 它指示应用程序是否将检查是否可以在已知主机中找到主机公钥。此外，可用的参数值是ask、yes和no，其中ask是默认值。如果我们将此属性设置为yes，JSch 将永远不会自动将主机密钥添加到known_hosts文件，并且它将拒绝连接到主机密钥已更改的主机。这会强制用户手动添加所有新主机。如果我们将其设置为 no，JSch 会自动将新的主机密钥添加到已知主机列表中 compression.s2c – 指定是否对从服务器到客户端应用程序的数据流使用压缩。可用值为zlib和none，其中第二个是默认值 compression.c2s – 指定是否对客户端-服务器方向的数据流使用压缩。可用值为zlib和none，其中第二个是默认值 Apache MINA SSHDApache SSHD 是一个 100% 纯 Java 库，支持客户端和服务器端的 SSH 协议。该库基于Apache MINA，这是一个可扩展的高性能异步 IO 库。 首先，让我们将sshd Maven 依赖添加到我们的pom.xml文件中： 12345&lt;dependency&gt; &lt;groupId&gt;org.apache.sshd&lt;/groupId&gt; &lt;artifactId&gt;sshd-core&lt;/artifactId&gt; &lt;version&gt;2.8.0&lt;/version&gt;&lt;/dependency&gt; 执行同样，建立ssh连接需要提供用户名，密码，主机地址，端口，除此之外，sshd可以设置连接超时时间，以下提供简单的代码示例： 123456789101112131415161718192021222324252627282930313233343536public static void execCommand(String username, String password, String host, Integer port, Integer defaultTimeoutSeconds, String command) throws IOException { SshClient client = SshClient.setUpDefaultClient(); client.start(); try (ClientSession session = client.connect(username, host, port) .verify(defaultTimeoutSeconds, TimeUnit.SECONDS) .getSession()) { session.addPasswordIdentity(password); session.auth().verify(defaultTimeoutSeconds, TimeUnit.SECONDS); try (ByteArrayOutputStream responseStream = new ByteArrayOutputStream(); ByteArrayOutputStream errorResponseStream = new ByteArrayOutputStream(); ClientChannel channel = session.createChannel(Channel.CHANNEL_SHELL)) { channel.setOut(responseStream); channel.setErr(errorResponseStream); try { channel.open().verify(defaultTimeoutSeconds, TimeUnit.SECONDS); try (OutputStream pipedIn = channel.getInvertedIn()) { pipedIn.write(command.getBytes()); pipedIn.flush(); } channel.waitFor(EnumSet.of(ClientChannelEvent.CLOSED), TimeUnit.SECONDS.toMillis(defaultTimeoutSeconds)); String errorString = new String(errorResponseStream.toByteArray()); if (!errorString.isEmpty()) { log.warn(errorString); } String responseString = new String(responseStream.toByteArray()); if (!responseString.isEmpty()) { log.info(responseString); } } finally { channel.close(false); } } } finally { client.stop(); } } 结论与往常一样，本文中使用的源代码可在 GitHub 上获得。","link":"/2022/05/15/java-ssh/"},{"title":"Mybatis-plus遇到MySQL关键字如何解决","text":"Mybatis-plus遇到MySQL关键字如何解决在我们开发中经常会遇到在实体类中某个字段是MySQL的关键字，例如： 1234567@TableNamepublic class User { private Long id; private String username; private String describe;} 在我们使用Mybatis查询是会遇到报错，提示信息： 11064 - You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near 'describe from user' at line 1, Time: 0.009000s 这是因为Mybatis在执行sql时并没有将查询字段并没有通过**``**符号，所以MySQL会把describe当作关键字。 首先遇到这种情况，一我们可以更改字段名避免使用MySQL的关键字；二如果字段名不方便修改，那么我们可以使用@TableField显示的将字段使用**``**。修改后实体类如下： 1234567@TableNamepublic class User { private Long id; private String username; @TableName(\"`describe`\") private String describe;}","link":"/2022/05/18/mybatis-mysql-keyword/"},{"title":"SpringGateway使用SpringSecurity防止CSRF攻击","text":"SpringGateway使用SpringSecurity防止CSRF攻击配置CSRF保护123456@Beanpublic SecurityWebFilterChain springSecurityFilterChain(ServerHttpSecurity http) { http .csrf(csrf -&gt; csrf.csrfTokenRepository(CookieServerCsrfTokenRepository.withHttpOnlyFalse())) return http.build();} 以上通过Cookie持久化XSRF-TOKEN值，jS读取cookie中的值发起请求时需携带X-XSRF-TOKEN请求头，默认情况GET，HEAD，TRACE，OPTIONS请求方式是放行的，具体实现在DefaultRequireCsrfProtectionMatcher类。如果需要特殊定制，可以自定义实现类实现ServerWebExchangeMatcher,并替换默认DefaultRequireCsrfProtectionMatcher: 1234567@Bean public SecurityWebFilterChain springSecurityFilterChain(ServerHttpSecurity http) { http .csrf(csrf -&gt; csrf.csrfTokenRepository(CookieServerCsrfTokenRepository.withHttpOnlyFalse()) .requireCsrfProtectionMatcher(new CustomServerWebExchangeMatcher()); return http.build(); } CookieServerCsrfTokenRepository does not add cookie在我们按照上述配置分别测试GET请求和POST请求时，发现GET请求响应cookie中并没有XSRF-TOKEN，原因在响应式编程中CsrfToken并没有被订阅。具体问题解析在Spring Security issues中找到答案；最后也提供了解决方式： 12345678910111213141516@Slf4j@Componentpublic class CsrfHelperFilter implements WebFilter { @Override public Mono&lt;Void&gt; filter(ServerWebExchange exchange, WebFilterChain chain) { String key = CsrfToken.class.getName(); Mono&lt;CsrfToken&gt; csrfToken = null != exchange.getAttribute(key) ? exchange.getAttribute(key) : Mono.empty(); return csrfToken.doOnSuccess(token -&gt; { ResponseCookie cookie = ResponseCookie.from(\"XSRF-TOKEN\", token.getToken()).maxAge(Duration.ofHours(1)) .httpOnly(false).path(\"/\").build(); log.debug(\"Cookie: {}\", cookie); exchange.getResponse().getCookies().add(\"XSRF-TOKEN\", cookie); }).then(chain.filter(exchange)); }} 结论与往常一样，本文中使用的源代码可在 GitHub 上获得。","link":"/2022/06/22/spring-gateway-csrf/"},{"title":"Java Weekly 第1期","text":"精选文章 &gt;&gt;从 Postman REST 客户端发送 CSRF 令牌 [baeldung.com] &gt;&gt;使用 Spring Boot 客户端配置为 Kafka 实现 2 路 SSL 和 ACL 身份验证 [medium.com] 2022 Java 程序员路线图 [medium.com] 技术&amp;思考 &gt;&gt;当我开始担任软件工程师时，我想知道的 10 件事 [medium.com]","link":"/2022/06/12/java-weekly-1/"},{"title":"Spring项目的resources目录下的文件读取","text":"src/main/resources和src/test/resources下的资源读取方式1. 一般maven会将spring工程编译到target文件夹下，/target/classes就是其根目录。而src/main/resources下的文件被复制到了这个classes文件夹下。 2. maven会将src/test/java文件夹下的代码编译到target/test-classes文件夹下。同样的，如果src/test/resources下有资源文件的话，就复制到target/test-classes文件夹下。 测试代码运行时，优先使用test-classes文件夹下的资源文件，如果不存在，再使用classes文件夹下的资源文件。 前两种底层代码都是通过类加载器读取流 1. 使用org.springframework.core.io.ClassPathResource读取，开发环境和生产环境(Linux下jar包运行读取)都能读取。 12345678910Resource resource=new ClassPathResource(\"3.png\");InputStream fis = resource.getInputStream();OutputStream fos=new FileOutputStream(\"E://3.png\");int len=0;byte[] buf=new byte[1024];while((len=fis.read(buf,0,buf.length))!=-1){ fos.write(buf,0,len);}fos.close();fis.close(); 2. 使用流的方式来读取，两种方式，开发环境和生产环境(Linux下jar包运行读取)都能读取。 方式一： 123456789InputStream fis = this.getClass().getResourceAsStream(\"/3.png\");OutputStream fos=new FileOutputStream(\"E://3.png\");int len=0;byte[] buf=new byte[1024];while((len=fis.read(buf,0,buf.length))!=-1){ fos.write(buf,0,len);}fos.close();fis.close(); 方式二： 123456789InputStream fis = Thread.currentThread().getContextClassLoader().getResourceAsStream(\"/3.png\");OutputStream fos=new FileOutputStream(\"E://3.png\");int len=0;byte[] buf=new byte[1024];while((len=fis.read(buf,0,buf.length))!=-1){ fos.write(buf,0,len);}fos.close();fis.close(); 3. 使用org.springframework.core.io.ResourceLoader 读取，开发环境和生产环境(Linux下jar包运行读取)都能读取。 12345678910111213141516@AutowiredResourceLoader resourceLoader;@Testpublic void resourceLoaderTest() throws IOException { Resource resource = resourceLoader.getResource(\"classpath:3.png\"); InputStream fis = resource.getInputStream(); OutputStream fos=new FileOutputStream(\"E://3.png\"); int len=0; byte[] buf=new byte[1024]; while((len=fis.read(buf,0,buf.length))!=-1){ fos.write(buf,0,len); } fos.close(); fis.close();} 4. 使用File file=new File(“src/main/resources/file.txt”); 读取，只能在开发环境中读取，不能再生产环境中读取(Linux下jar包运行读取)。 1234567891011File file=new File(\"src/main/resources/3.png\");InputStream fis=new FileInputStream(file);OutputStream fos=new FileOutputStream(\"E://3.png\");int len=0;byte[] buf=new byte[1024];while ((len=fis.read(buf,0,buf.length))!=-1){ fos.write(buf,0,len); System.out.println(\"---\");}fos.close();fis.close(); 5. 使用org.springframework.util.ResourceUtils 读取，只能在开发环境中读取，不能再生产环境中读取(Linux下jar包运行读取)。 12345678910File file = ResourceUtils.getFile(\"src/main/resources/3.png\");InputStream fis=new FileInputStream(file);OutputStream fos=new FileOutputStream(\"E://3.png\");int len=0;byte[] buf=new byte[1024];while((len=fis.read(buf,0,buf.length))!=-1){ fos.write(buf,0,len);}fos.close();fis.close(); 结论与往常一样，本文中使用的源代码可在 GitHub 上获得。","link":"/2022/05/09/spring-read-resource/"},{"title":"注解@PathVariable、@RequestParam、@RequestBody、@RequestHeader讲解","text":"@PathVariable绑定请求参数，当@RequestMapping(value=”/get/{id}”），可以获取url格式/get/{id}中{id}的值 属性 说明 value 指定request参数名 name 指定request参数名（与value二选一） required 是否需要该参数。 默认为true，如果请求中缺少参数，则会引发异常 当url为 get/{id}/{name} 12@RequestMapping(\"/get/{id}/{name}\")public String get(@PathVariable Integer id,@PathVariable String name) 当需要对url变量进行更加精确的定义时，可以定义正则表达式进行更精确地控制，定义语法是{变量名: 正则表达式} 12@RequestMapping(\"/get/{name:[a-zA-Z0-9]+}\")public String get(@PathVariable String name) 如此设置URL变量规则后，不合法的URL则不会被处理，直接由SpringMVC框架返回404NotFound。 @RequestParam绑定来自请求url中的参数，可以获取url格式：?username=”zhangsan”。 属性 说明 value 指定request参数名 name 指定request参数名（与value二选一） required 是否需要该参数。 默认为true，如果请求中缺少参数，则会引发异常 defaultValue 未提供request参数或具有空值时用作后备的默认值,当设置默认值时，required隐式的设为了false 如果在传递参数时url是?userName=zhangsan&amp;userName=wangwu，即两个同名参数，后台可以用以下方法接收： 123public String getUserName(@RequestParam(value=\"userName\") String [] userNames)//或者是public String getUserName(@RequestParam(value=\"list\") List&lt;String&gt; list) Get/POST请求测试12345678public String get(@RequestParam Map map)//在url中？后面添加参数可以接收public String get(@RequestParam String id)//在url中？后面添加参数可以接收 public String get(@RequestParam Object object)//参数接收不到 @RequestBody绑定来自HTTP请求体 的参数 @RequestBody用来处理 Content-Type 为 application/json、application/xml编码的内容 属性 说明 required 是否需要该参数。 默认为true，如果请求中缺少参数，则会引发异常 GET/POST 请求测试12345678public String get(@RequestBody Map map)//json参数可以接收public String get(@RequestBody String id)//json参数可以接收,但是字符串接收的是整个json格式的字符串,如打印：{\"id\":3,\"name\":\"ddd\"} public String get(@RequestBody Object object)//json参数可以接收 指定实体类中的属性对应json中的key值@JsonProperty、@JsonAlias 1234567@Datapublic class Employee { @JsonProperty(value = \"ids\") //json中的key为ids可以识别，key为id不能识别 private String id; @JsonAlias(value = {\"NAME\",\"ii\"}) //json中的key为NAME、ii、name都能识别 private String name;} @RequestHeader从Http请求头中提取指定的某个请求头。 属性 说明 value 指定请求头中的key name 指定请求头中的key（与value二选一） required 是否需要该参数。 默认为true，如果请求中缺少参数，则会引发异常 defaultValue 未提供request参数或具有空值时用作后备的默认值,当设置默认值时，required隐式的设为了false 1public String get(@RequestHeader(value = \"Content-Type\") String contextType){}","link":"/2022/05/09/spring-mvc-annotation/"},{"title":"设计模式-单例模式","text":"单例模式单例模式是设计模式中比较简单的模式，也是很常用的模式，其定义如下： 确保某一个类只有一个实例，而且自行实例化并向整个系统提供这个实例。 通用类图如下： 通过私有化构造函数确保在一个应用中只有一个实例，并提供静态方法发布对象。 单例模式通用代码（也被称为饿汉式）： 12345678910111213141516public class Singleton { private static final Singleton singleton= new Singleton(); //限制多个对象 private Singleton (){} //通过该方法获得实例对象 public static Singleton getSingleton() { return singleton; } //在类中其他方法，尽量是static public static void doSomething(){ ... }} 单例模式的优点 减少内存开支，特别是一个对象频繁的创建和销毁时。 减少系统性能开销，当一个对象的产生需要比较多的资源时，可以通过启动时产生一个单例对象。 单例模式可以避免对资产的多重占用。 单例模式可以在系统设置全局的访问点，优化和共享资源访问。 单例模式的缺点 单例模式对测试不利，在并行开发中，如果单例模式没有完成，是不能进行测试的，因为没有接口也不能mock的方式虚拟一个对象 单例模式与单一职责原则有冲突，一个类应该只实现一个逻辑，单例模式把“要单例”和业务逻辑合在一个类中 单例模式使用场景系统中要求一个类只有一个对象，当存在多个对象时会产生错误影响，可以使用单例模式。 要求生成唯一序列号的环境 在项目中需要一个共享访问点和共享数据 创建一个对象需要消耗很多资源。 需要定义大量的静态常量和静态方法（如工具类） 单例模式的注意事项在高并发情况下，单例模式存在线程同步问题，如下面的一种单例模式实现方式（也称为懒汉式）： 12345678910111213public class Singleton { private static Singleton singleton = null; //限制产生多个对象 private Singleton(){} public static Singleton getSingleton() { if(singleton == null){ singleton = new Singleton(); } return singleton; }} 在并发量增加时可能会出现多个实例，如一个线程A执行到singleton = new Singleton()，但是还没有获得对象，第二个线程B也在执行，执行到singleton == null判断，判断条件为真，于是运行下去也创建了一个对象。 解决线程不安全问题方法有很多，一使用饿汉式的实现方式，静态变量在类加载时初始化，类加载过程是线程安全的，所以饿汉式没有线程安全问题；二是使用Java的锁机制，以下代码示例单例模式（懒汉式）的双重检锁机制： 1234567891011121314151617public class Singleton { private static volatile Singleton singleton = null; //限制产生多个对象 private Singleton(){} public static Singleton getSingleton() { if (singleton == null) { synchronized (Singleton.class) { if (singleton == null) { singleton = new Singleton(); } } } return singleton; }} 总之单例模式比较简单而且应用非常广泛，在Spring框架中每个Bean默认就是单例的。 结论与往常一样，本文中使用的源代码可在 GitHub 上获得。","link":"/2022/05/11/singleton-pattern/"},{"title":"SpringBoot启动完成前后执行某个方法","text":"在项目启动完成之前 实现ApplicationListener，ContextRefreshedEvent为启动事件。 1234567@Componentpublic class ApplicationListenerDemo implements ApplicationListener&lt;ContextRefreshedEvent&gt; { @Override public void onApplicationEvent(ContextRefreshedEvent contextRefreshedEvent) { System.out.println(\"applicationListener before server success\"); }} 在项目启动完成之后方式一 ：实现ApplicationRunner接口1234567@Componentpublic class ApplicationRunnerDemo implements ApplicationRunner { @Override public void run(ApplicationArguments args) throws Exception { System.out.println(\"run after server success\"); }} 方式二：实现CommandLineRunner接口123456public class CommandLineRunnerDemo implements CommandLineRunner { @Override public void run(String... args) throws Exception { System.out.println(\"commandLineRunner after server success\"); }} 原理启动类的run方法调用了callRunners方法 1234567891011121314151617181920212223242526272829303132333435363738394041public ConfigurableApplicationContext run(String... args) { StopWatch stopWatch = new StopWatch(); stopWatch.start(); ConfigurableApplicationContext context = null; Collection&lt;SpringBootExceptionReporter&gt; exceptionReporters = new ArrayList(); this.configureHeadlessProperty(); SpringApplicationRunListeners listeners = this.getRunListeners(args); listeners.starting(); Collection exceptionReporters; try { ApplicationArguments applicationArguments = new DefaultApplicationArguments(args); ConfigurableEnvironment environment = this.prepareEnvironment(listeners, applicationArguments); this.configureIgnoreBeanInfo(environment); Banner printedBanner = this.printBanner(environment); context = this.createApplicationContext(); exceptionReporters = this.getSpringFactoriesInstances(SpringBootExceptionReporter.class, new Class[]{ConfigurableApplicationContext.class}, context); this.prepareContext(context, environment, listeners, applicationArguments, printedBanner); this.refreshContext(context); this.afterRefresh(context, applicationArguments); stopWatch.stop(); if (this.logStartupInfo) { (new StartupInfoLogger(this.mainApplicationClass)).logStarted(this.getApplicationLog(), stopWatch); } listeners.started(context); //执行callRunners方法 this.callRunners(context, applicationArguments); } catch (Throwable var10) { this.handleRunFailure(context, var10, exceptionReporters, listeners); throw new IllegalStateException(var10); } try { listeners.running(context); return context; } catch (Throwable var9) { this.handleRunFailure(context, var9, exceptionReporters, (SpringApplicationRunListeners)null); throw new IllegalStateException(var9); } } callRunners方法会调用容器里所有实现了ApplicationRunner、CommandLineRunner接口的方法 12345678910111213141516171819private void callRunners(ApplicationContext context, ApplicationArguments args) { List&lt;Object&gt; runners = new ArrayList(); runners.addAll(context.getBeansOfType(ApplicationRunner.class).values()); runners.addAll(context.getBeansOfType(CommandLineRunner.class).values()); AnnotationAwareOrderComparator.sort(runners); Iterator var4 = (new LinkedHashSet(runners)).iterator(); while(var4.hasNext()) { Object runner = var4.next(); if (runner instanceof ApplicationRunner) { this.callRunner((ApplicationRunner)runner, args); } if (runner instanceof CommandLineRunner) { this.callRunner((CommandLineRunner)runner, args); } } }","link":"/2022/05/10/spring-start-event/"},{"title":"SpringBoot整合redis","text":"Redis介绍Redis是当前比较热门的NOSQL系统之一，它是一个开源的使用ANSI c语言编写的key-value存储系统（区别于MySQL的二维表格的形式存储。）。和Memcache类似，但很大程度补偿了Memcache的不足。和Memcache一样，Redis数据都是缓存在计算机内存中，不同的是，Memcache只能将数据缓存到内存中，无法自动定期写入硬盘，这就表示，一断电或重启，内存清空，数据丢失。所以Memcache的应用场景适用于缓存无需持久化的数据。而Redis不同的是它会周期性的把更新的数据写入磁盘或者把修改操作写入追加的记录文件，实现数据的持久化。 Redis的特点： Redis读取的速度是110000次/s，写的速度是81000次/s； 原子 。Redis的所有操作都是原子性的，同时Redis还支持对几个操作全并后的原子性执行。 支持多种数据结构：string（字符串）；list（列表）；hash（哈希），set（集合）；zset(有序集合) 持久化，集群部署 支持过期时间，支持事务，消息订阅 引入依赖springboot版本使用的是2.3.0 123456789&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.apache.commons&lt;/groupId&gt; &lt;artifactId&gt;commons-pool2&lt;/artifactId&gt; &lt;version&gt;2.6.1&lt;/version&gt; &lt;/dependency&gt; application.yml1234567891011121314spring: redis: host: 192.168.234.131 #Redis服务器地址 database: 0 #Redis数据库索引（默认为0） port: 6379 #Redis服务器连接端口 password: 123456 #Redis服务器连接密码（默认为空） timeout: 180000 #连接超时时间（毫秒） lettuce: pool: max-active: 20 #连接池最大连接数（使用负值表示没有限制） max-wait: 10000 #连接池最大阻塞等待时间（使用负值表示没有限制） max-idle: 5 #连接池中的最大空闲连接 min-idle: 0 #连接池中的最小空闲连接 shutdown-timeout: 100 #关闭超时时间 添加redis配置类1234567891011121314151617181920212223242526272829303132333435363738394041424344@EnableCaching@Configurationpublic class RedisConfig extends CachingConfigurerSupport { @Bean public RedisTemplate&lt;String, Object&gt; redisTemplate(RedisConnectionFactory factory) { RedisTemplate&lt;String, Object&gt; template = new RedisTemplate&lt;&gt;(); RedisSerializer&lt;String&gt; redisSerializer = new StringRedisSerializer(); Jackson2JsonRedisSerializer jackson2JsonRedisSerializer = new Jackson2JsonRedisSerializer(Object.class); ObjectMapper om = new ObjectMapper(); om.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.ANY); om.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL); jackson2JsonRedisSerializer.setObjectMapper(om); template.setConnectionFactory(factory); //key序列化方式 template.setKeySerializer(redisSerializer); //value序列化 template.setValueSerializer(jackson2JsonRedisSerializer); //value hashmap序列化 template.setHashValueSerializer(jackson2JsonRedisSerializer); return template; } @Bean public CacheManager cacheManager(RedisConnectionFactory factory) { RedisSerializer&lt;String&gt; redisSerializer = new StringRedisSerializer(); Jackson2JsonRedisSerializer jackson2JsonRedisSerializer = new Jackson2JsonRedisSerializer(Object.class); //解决查询缓存转换异常的问题 ObjectMapper om = new ObjectMapper(); om.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.ANY); om.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL); jackson2JsonRedisSerializer.setObjectMapper(om); // 配置序列化（解决乱码的问题）,过期时间600秒 RedisCacheConfiguration config = RedisCacheConfiguration.defaultCacheConfig() .entryTtl(Duration.ofSeconds(600)) .serializeKeysWith(RedisSerializationContext.SerializationPair.fromSerializer(redisSerializer)) .serializeValuesWith(RedisSerializationContext.SerializationPair.fromSerializer(jackson2JsonRedisSerializer)) .disableCachingNullValues(); RedisCacheManager cacheManager = RedisCacheManager.builder(factory) .cacheDefaults(config) .build(); return cacheManager; }} SpringBoot缓存注解@EnableCaching开启基于注解的缓存 缓存@Cacheable根据方法对其返回结果进行缓存，下次请求时，如果缓存存在，则直接读取缓存数据返回；如果缓存不存在，则执行方法，并把返回的结果存入缓存中。一般用在查询方法上。属性值如下： 属性名 解释 value 缓存名，必填，它指定了你的缓存存放在哪块命名空间 cacheNames 与 value 差不多，二选一即可 key 缓存的 key，可以为空，如果指定要按照 SpEL 表达 式编写，如果不指定，则缺省按照方法的所有参数进行组合 keyGenerator 缓存数据时key生成策略，与key属性互斥 cacheManager 指定自定义CacheManager的名称，与cacheResolver属性互斥 cacheResolver 指定自定义的CacheResolver名称 condition 缓存的条件，可以为空，表示方法结果始终被缓存。而使用 SpEL 编写，返回 true 或者 false，只有为 true 才进行缓存/清除缓存，在调用方法之前之后都能判断 unless 用于否决缓存的，不像condition，该表达式只在方法执行之后判断，此时可以拿到返回值result进行判 断。条件为true不会缓存，fasle才缓存 sync 是否同步，默认是false，如果为true，unless将不受支持 @CachePut使用该注解标志的方法，每次都会执行，并将结果存入指定的缓存中。其他方法可以直接从响应的缓存中读取缓存数据，而不需要再去查询数据库。一般用在新增和更新方法上。属性值如下： 属性名 解释 value 缓存名，必填，它指定了你的缓存存放在哪块命名空间 cacheNames 与 value 差不多，二选一即可 key 缓存的 key，可以为空，如果指定要按照 SpEL 表达式编写，如果不指定，则缺省按照方法的所有参数进行组合 keyGenerator 缓存数据时key生成策略，与key属性互斥 cacheManager 指定自定义CacheManager的名称，与cacheResolver属性互斥 cacheResolver 指定自定义的CacheResolver名称 condition 缓存的条件，可以为空，表示方法结果始终被缓存。而使用SpEL 编写，返回 true 或者 false，只有为 true 才进行缓存/清除缓存，在调用方法之前之后都能判断 unless 用于否决缓存的，不像condition，该表达式只在方法执行之后判断，此时可以拿到返回值result进行判 断。条件为true不会缓存，fasle才缓存 @CacheEvict使用该注解标志的方法，会清空指定的缓存。一般用在更新或者删除方法上，属性值如下： 属性名 解释 value 缓存名，必填，它指定了你的缓存存放在哪块命名空间 cacheNames 与 value 差不多，二选一即可 key 缓存的 key，可以为空，如果指定要按照 SpEL 表达式编写，如果不指定，则缺省按照方法的所有参数进行组合 keyGenerator 缓存数据时key生成策略，与key属性互斥 cacheManager 指定自定义CacheManager的名称，与cacheResolver属性互斥 cacheResolver 指定自定义的CacheResolver名称 condition 缓存的条件，可以为空，表示方法结果始终被缓存。而使用 SpEL 编写，返回 true 或者 false，只有为 true 才进行缓存/清除缓存，在调用方法之前之后都能判断 allEntries 是否清空所有缓存内容，缺省为 false。如果指定为 true，则方法调用后将立即清空所有缓存。注意不允许将此参数设置为true并指定一个key beforeInvocation 是否在方法执行前就清空，缺省为 false。缺省情况下，如果方法执行抛出异常，则不会清空缓存。如果指定 为 true，则在方法还没有执行的时候就清空缓存。 @Caching不同或相同类型的缓存注释的组注释，用于定制复杂的缓存规则。 属性名 解释 cacheable 默认为空，可以定义一个或多个@Cacheable put 默认为空，可以定义一个或多个@CachePut evict 默认为空，可以定义一个或多个@CacheEvict @CacheConfig用于标注在类上，可以存放该类中所有缓存的公有属性，比如设置缓存的名字。 属性名 解释 cacheNames 与 value 差不多，二选一即可 keyGenerator 缓存数据时key生成策略，与key属性互斥 cacheManager 指定自定义CacheManager的名称，如果没有设置cacheResolver，并且在类中的缓存注解未设置缓存解析器和缓存管理器，则使用该管理器而不是默认值。 cacheResolver 指定自定义CacheResolver的名称，如果在类中的缓存注解没有设置解析器和缓存管理器，则使用此解析器而不是默认值。 SpEL 名字 位置 描述 示例 methodName root object 当前被调用的方法名 #root.methodName method root object 当前被调用的方法 #root.method.name target root object 当前被调用的目标对象 #root.target targetClass root object 当前被调用的目标对象类 #root.targetClass args root object 当前被调用的方法的参数列表 #root.args[0] 表示参数列表第一个参数 caches root object 当前方法调用使用的缓存列表（如@Cacheable(value={“cache1”, “cache2”})），则有两个cache #root.caches[0].name，取缓存列表中第一个缓存名称 argument name evaluation context(上下文) 方法参数的名字. 可以直接 #参数名 ，也可以使用 #p0或#a0 的 形式，0代表参数的索引； #id、#p0,#a0 result evaluation context 方法执行后的返回值（仅当方法执行之后的判断有效，如 ‘unless’，’cache put’的表达式 ’cache evict’的属性beforeInvocation=false #result，#result.id(返回结果的属性名) 使用RestTemplate操作redis1.redisTemplate.opsForValue();//操作字符串 2.redisTemplate.opsForHash();//操作hash 3.redisTemplate.opsForList();//操作list 4.redisTemplate.opsForSet();//操作set 5.redisTemplate.opsForZSet();//操作有序set 其他操作不一一列举 测试首先我们先编写一个小Demo，我持久化层使用的是mybatis,这里代码很简单，就直接越过。 然后看一下我们service层代码，在方法上添加了@Cacheable注解 123456789101112@Servicepublic class DepartmentService { @Autowired private DepartmentMapper departmentMapper; @Cacheable(cacheNames = \"dep\",key = \"#id\") public Department getDep(Integer id){ Department byId = departmentMapper.getById(id); return byId; }} 编写测试方法，看打印的日志结果 12345@Test void contextLoads() { Department dep = departmentService.getDep(1); System.out.println(dep); } 第一次执行从数据库里查数据，日志打印出SQL语句第二次执行，日志没有打印SQL语句，说明是从redis缓存取数据而我们也可以打开Redis Desktop Manager查看，数据的确存进缓存中了","link":"/2022/05/10/springboot-integrate-redis/"}],"tags":[{"name":"ssh","slug":"ssh","link":"/tags/ssh/"},{"name":"mybatis","slug":"mybatis","link":"/tags/mybatis/"},{"name":"spring cloud","slug":"spring-cloud","link":"/tags/spring-cloud/"},{"name":"spring boot","slug":"spring-boot","link":"/tags/spring-boot/"},{"name":"spring mvc","slug":"spring-mvc","link":"/tags/spring-mvc/"},{"name":"redis","slug":"redis","link":"/tags/redis/"}],"categories":[{"name":"设计模式","slug":"设计模式","link":"/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"java","slug":"java","link":"/categories/java/"},{"name":"weekly","slug":"weekly","link":"/categories/weekly/"},{"name":"Mybatis","slug":"Mybatis","link":"/categories/Mybatis/"},{"name":"SpringCloud","slug":"SpringCloud","link":"/categories/SpringCloud/"},{"name":"SpringBoot","slug":"SpringBoot","link":"/categories/SpringBoot/"}]}